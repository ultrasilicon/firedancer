// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: geyser.proto
#ifndef GRPC_geyser_2eproto__INCLUDED
#define GRPC_geyser_2eproto__INCLUDED

#include "geyser.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace geyser {

class Geyser final {
 public:
  static constexpr char const* service_full_name() {
    return "geyser.Geyser";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>> Subscribe(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>>(SubscribeRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>> AsyncSubscribe(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>>(AsyncSubscribeRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>> PrepareAsyncSubscribe(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>>(PrepareAsyncSubscribeRaw(context, cq));
    }
    virtual ::grpc::Status SubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::geyser::SubscribeReplayInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::SubscribeReplayInfoResponse>> AsyncSubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::SubscribeReplayInfoResponse>>(AsyncSubscribeReplayInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::SubscribeReplayInfoResponse>> PrepareAsyncSubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::SubscribeReplayInfoResponse>>(PrepareAsyncSubscribeReplayInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status Ping(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::geyser::PongResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::PongResponse>> AsyncPing(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::PongResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::PongResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::PongResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::geyser::GetLatestBlockhashResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetLatestBlockhashResponse>> AsyncGetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetLatestBlockhashResponse>>(AsyncGetLatestBlockhashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetLatestBlockhashResponse>> PrepareAsyncGetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetLatestBlockhashResponse>>(PrepareAsyncGetLatestBlockhashRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::geyser::GetBlockHeightResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetBlockHeightResponse>> AsyncGetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetBlockHeightResponse>>(AsyncGetBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetBlockHeightResponse>> PrepareAsyncGetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetBlockHeightResponse>>(PrepareAsyncGetBlockHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::geyser::GetSlotResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetSlotResponse>> AsyncGetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetSlotResponse>>(AsyncGetSlotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetSlotResponse>> PrepareAsyncGetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetSlotResponse>>(PrepareAsyncGetSlotRaw(context, request, cq));
    }
    virtual ::grpc::Status IsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::geyser::IsBlockhashValidResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::IsBlockhashValidResponse>> AsyncIsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::IsBlockhashValidResponse>>(AsyncIsBlockhashValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::IsBlockhashValidResponse>> PrepareAsyncIsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::IsBlockhashValidResponse>>(PrepareAsyncIsBlockhashValidRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::geyser::GetVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Subscribe(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::geyser::SubscribeRequest,::geyser::SubscribeUpdate>* reactor) = 0;
      virtual void SubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest* request, ::geyser::SubscribeReplayInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest* request, ::geyser::SubscribeReplayInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Ping(::grpc::ClientContext* context, const ::geyser::PingRequest* request, ::geyser::PongResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ping(::grpc::ClientContext* context, const ::geyser::PingRequest* request, ::geyser::PongResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest* request, ::geyser::GetLatestBlockhashResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest* request, ::geyser::GetLatestBlockhashResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest* request, ::geyser::GetBlockHeightResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest* request, ::geyser::GetBlockHeightResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest* request, ::geyser::GetSlotResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest* request, ::geyser::GetSlotResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest* request, ::geyser::IsBlockhashValidResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest* request, ::geyser::IsBlockhashValidResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest* request, ::geyser::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest* request, ::geyser::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* SubscribeRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* AsyncSubscribeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::SubscribeReplayInfoResponse>* AsyncSubscribeReplayInfoRaw(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::SubscribeReplayInfoResponse>* PrepareAsyncSubscribeReplayInfoRaw(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::PongResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::PongResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetLatestBlockhashResponse>* AsyncGetLatestBlockhashRaw(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetLatestBlockhashResponse>* PrepareAsyncGetLatestBlockhashRaw(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetBlockHeightResponse>* AsyncGetBlockHeightRaw(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetBlockHeightResponse>* PrepareAsyncGetBlockHeightRaw(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetSlotResponse>* AsyncGetSlotRaw(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetSlotResponse>* PrepareAsyncGetSlotRaw(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::IsBlockhashValidResponse>* AsyncIsBlockhashValidRaw(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::IsBlockhashValidResponse>* PrepareAsyncIsBlockhashValidRaw(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::geyser::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>> Subscribe(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>>(SubscribeRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>> AsyncSubscribe(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>>(AsyncSubscribeRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>> PrepareAsyncSubscribe(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>>(PrepareAsyncSubscribeRaw(context, cq));
    }
    ::grpc::Status SubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::geyser::SubscribeReplayInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::SubscribeReplayInfoResponse>> AsyncSubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::SubscribeReplayInfoResponse>>(AsyncSubscribeReplayInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::SubscribeReplayInfoResponse>> PrepareAsyncSubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::SubscribeReplayInfoResponse>>(PrepareAsyncSubscribeReplayInfoRaw(context, request, cq));
    }
    ::grpc::Status Ping(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::geyser::PongResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::PongResponse>> AsyncPing(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::PongResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::PongResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::PongResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    ::grpc::Status GetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::geyser::GetLatestBlockhashResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetLatestBlockhashResponse>> AsyncGetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetLatestBlockhashResponse>>(AsyncGetLatestBlockhashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetLatestBlockhashResponse>> PrepareAsyncGetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetLatestBlockhashResponse>>(PrepareAsyncGetLatestBlockhashRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::geyser::GetBlockHeightResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetBlockHeightResponse>> AsyncGetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetBlockHeightResponse>>(AsyncGetBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetBlockHeightResponse>> PrepareAsyncGetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetBlockHeightResponse>>(PrepareAsyncGetBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status GetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::geyser::GetSlotResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetSlotResponse>> AsyncGetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetSlotResponse>>(AsyncGetSlotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetSlotResponse>> PrepareAsyncGetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetSlotResponse>>(PrepareAsyncGetSlotRaw(context, request, cq));
    }
    ::grpc::Status IsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::geyser::IsBlockhashValidResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::IsBlockhashValidResponse>> AsyncIsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::IsBlockhashValidResponse>>(AsyncIsBlockhashValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::IsBlockhashValidResponse>> PrepareAsyncIsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::IsBlockhashValidResponse>>(PrepareAsyncIsBlockhashValidRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::geyser::GetVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::geyser::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Subscribe(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::geyser::SubscribeRequest,::geyser::SubscribeUpdate>* reactor) override;
      void SubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest* request, ::geyser::SubscribeReplayInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void SubscribeReplayInfo(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest* request, ::geyser::SubscribeReplayInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Ping(::grpc::ClientContext* context, const ::geyser::PingRequest* request, ::geyser::PongResponse* response, std::function<void(::grpc::Status)>) override;
      void Ping(::grpc::ClientContext* context, const ::geyser::PingRequest* request, ::geyser::PongResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest* request, ::geyser::GetLatestBlockhashResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLatestBlockhash(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest* request, ::geyser::GetLatestBlockhashResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest* request, ::geyser::GetBlockHeightResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeight(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest* request, ::geyser::GetBlockHeightResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest* request, ::geyser::GetSlotResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSlot(::grpc::ClientContext* context, const ::geyser::GetSlotRequest* request, ::geyser::GetSlotResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest* request, ::geyser::IsBlockhashValidResponse* response, std::function<void(::grpc::Status)>) override;
      void IsBlockhashValid(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest* request, ::geyser::IsBlockhashValidResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest* request, ::geyser::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::geyser::GetVersionRequest* request, ::geyser::GetVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* SubscribeRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* AsyncSubscribeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::SubscribeReplayInfoResponse>* AsyncSubscribeReplayInfoRaw(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::SubscribeReplayInfoResponse>* PrepareAsyncSubscribeReplayInfoRaw(::grpc::ClientContext* context, const ::geyser::SubscribeReplayInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::PongResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::PongResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::geyser::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetLatestBlockhashResponse>* AsyncGetLatestBlockhashRaw(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetLatestBlockhashResponse>* PrepareAsyncGetLatestBlockhashRaw(::grpc::ClientContext* context, const ::geyser::GetLatestBlockhashRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetBlockHeightResponse>* AsyncGetBlockHeightRaw(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetBlockHeightResponse>* PrepareAsyncGetBlockHeightRaw(::grpc::ClientContext* context, const ::geyser::GetBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetSlotResponse>* AsyncGetSlotRaw(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetSlotResponse>* PrepareAsyncGetSlotRaw(::grpc::ClientContext* context, const ::geyser::GetSlotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::IsBlockhashValidResponse>* AsyncIsBlockhashValidRaw(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::IsBlockhashValidResponse>* PrepareAsyncIsBlockhashValidRaw(::grpc::ClientContext* context, const ::geyser::IsBlockhashValidRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::geyser::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::geyser::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeReplayInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_Ping_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestBlockhash_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSlot_;
    const ::grpc::internal::RpcMethod rpcmethod_IsBlockhashValid_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Subscribe(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* stream);
    virtual ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* context, const ::geyser::SubscribeReplayInfoRequest* request, ::geyser::SubscribeReplayInfoResponse* response);
    virtual ::grpc::Status Ping(::grpc::ServerContext* context, const ::geyser::PingRequest* request, ::geyser::PongResponse* response);
    virtual ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* context, const ::geyser::GetLatestBlockhashRequest* request, ::geyser::GetLatestBlockhashResponse* response);
    virtual ::grpc::Status GetBlockHeight(::grpc::ServerContext* context, const ::geyser::GetBlockHeightRequest* request, ::geyser::GetBlockHeightResponse* response);
    virtual ::grpc::Status GetSlot(::grpc::ServerContext* context, const ::geyser::GetSlotRequest* request, ::geyser::GetSlotResponse* response);
    virtual ::grpc::Status IsBlockhashValid(::grpc::ServerContext* context, const ::geyser::IsBlockhashValidRequest* request, ::geyser::IsBlockhashValidResponse* response);
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::geyser::GetVersionRequest* request, ::geyser::GetVersionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Subscribe() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeReplayInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeReplayInfo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SubscribeReplayInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeReplayInfo(::grpc::ServerContext* context, ::geyser::SubscribeReplayInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::SubscribeReplayInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ping() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::geyser::PingRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::PongResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestBlockhash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestBlockhash() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetLatestBlockhash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockhash(::grpc::ServerContext* context, ::geyser::GetLatestBlockhashRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::GetLatestBlockhashResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeight() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeight(::grpc::ServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeight(::grpc::ServerContext* context, ::geyser::GetBlockHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::GetBlockHeightResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSlot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSlot() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetSlot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlot(::grpc::ServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSlot(::grpc::ServerContext* context, ::geyser::GetSlotRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::GetSlotResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsBlockhashValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsBlockhashValid() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_IsBlockhashValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBlockhashValid(::grpc::ServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsBlockhashValid(::grpc::ServerContext* context, ::geyser::IsBlockhashValidRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::IsBlockhashValidResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::geyser::GetVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::geyser::GetVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Subscribe<WithAsyncMethod_SubscribeReplayInfo<WithAsyncMethod_Ping<WithAsyncMethod_GetLatestBlockhash<WithAsyncMethod_GetBlockHeight<WithAsyncMethod_GetSlot<WithAsyncMethod_IsBlockhashValid<WithAsyncMethod_GetVersion<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackBidiHandler< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->Subscribe(context); }));
    }
    ~WithCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::geyser::SubscribeRequest, ::geyser::SubscribeUpdate>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeReplayInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeReplayInfo() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::SubscribeReplayInfoRequest, ::geyser::SubscribeReplayInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::SubscribeReplayInfoRequest* request, ::geyser::SubscribeReplayInfoResponse* response) { return this->SubscribeReplayInfo(context, request, response); }));}
    void SetMessageAllocatorFor_SubscribeReplayInfo(
        ::grpc::MessageAllocator< ::geyser::SubscribeReplayInfoRequest, ::geyser::SubscribeReplayInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::SubscribeReplayInfoRequest, ::geyser::SubscribeReplayInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubscribeReplayInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubscribeReplayInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::PingRequest, ::geyser::PongResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::PingRequest* request, ::geyser::PongResponse* response) { return this->Ping(context, request, response); }));}
    void SetMessageAllocatorFor_Ping(
        ::grpc::MessageAllocator< ::geyser::PingRequest, ::geyser::PongResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::PingRequest, ::geyser::PongResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLatestBlockhash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLatestBlockhash() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::GetLatestBlockhashRequest, ::geyser::GetLatestBlockhashResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::GetLatestBlockhashRequest* request, ::geyser::GetLatestBlockhashResponse* response) { return this->GetLatestBlockhash(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestBlockhash(
        ::grpc::MessageAllocator< ::geyser::GetLatestBlockhashRequest, ::geyser::GetLatestBlockhashResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::GetLatestBlockhashRequest, ::geyser::GetLatestBlockhashResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLatestBlockhash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockhash(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlockHeight() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::GetBlockHeightRequest, ::geyser::GetBlockHeightResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::GetBlockHeightRequest* request, ::geyser::GetBlockHeightResponse* response) { return this->GetBlockHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeight(
        ::grpc::MessageAllocator< ::geyser::GetBlockHeightRequest, ::geyser::GetBlockHeightResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::GetBlockHeightRequest, ::geyser::GetBlockHeightResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeight(::grpc::ServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSlot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSlot() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::GetSlotRequest, ::geyser::GetSlotResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::GetSlotRequest* request, ::geyser::GetSlotResponse* response) { return this->GetSlot(context, request, response); }));}
    void SetMessageAllocatorFor_GetSlot(
        ::grpc::MessageAllocator< ::geyser::GetSlotRequest, ::geyser::GetSlotResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::GetSlotRequest, ::geyser::GetSlotResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSlot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlot(::grpc::ServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSlot(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsBlockhashValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsBlockhashValid() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::IsBlockhashValidRequest, ::geyser::IsBlockhashValidResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::IsBlockhashValidRequest* request, ::geyser::IsBlockhashValidResponse* response) { return this->IsBlockhashValid(context, request, response); }));}
    void SetMessageAllocatorFor_IsBlockhashValid(
        ::grpc::MessageAllocator< ::geyser::IsBlockhashValidRequest, ::geyser::IsBlockhashValidResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::IsBlockhashValidRequest, ::geyser::IsBlockhashValidResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsBlockhashValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBlockhashValid(::grpc::ServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsBlockhashValid(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::geyser::GetVersionRequest, ::geyser::GetVersionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::geyser::GetVersionRequest* request, ::geyser::GetVersionResponse* response) { return this->GetVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetVersion(
        ::grpc::MessageAllocator< ::geyser::GetVersionRequest, ::geyser::GetVersionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::geyser::GetVersionRequest, ::geyser::GetVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Subscribe<WithCallbackMethod_SubscribeReplayInfo<WithCallbackMethod_Ping<WithCallbackMethod_GetLatestBlockhash<WithCallbackMethod_GetBlockHeight<WithCallbackMethod_GetSlot<WithCallbackMethod_IsBlockhashValid<WithCallbackMethod_GetVersion<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Subscribe() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeReplayInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeReplayInfo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SubscribeReplayInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ping() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestBlockhash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestBlockhash() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetLatestBlockhash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeight(::grpc::ServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSlot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSlot() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetSlot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlot(::grpc::ServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsBlockhashValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsBlockhashValid() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_IsBlockhashValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBlockhashValid(::grpc::ServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Subscribe() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeReplayInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeReplayInfo() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SubscribeReplayInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeReplayInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ping() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestBlockhash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestBlockhash() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetLatestBlockhash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockhash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeight() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeight(::grpc::ServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSlot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSlot() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetSlot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlot(::grpc::ServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSlot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsBlockhashValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsBlockhashValid() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_IsBlockhashValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBlockhashValid(::grpc::ServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsBlockhashValid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->Subscribe(context); }));
    }
    ~WithRawCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::geyser::SubscribeUpdate, ::geyser::SubscribeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeReplayInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeReplayInfo() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubscribeReplayInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubscribeReplayInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubscribeReplayInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Ping() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ping(context, request, response); }));
    }
    ~WithRawCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLatestBlockhash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLatestBlockhash() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestBlockhash(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLatestBlockhash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockhash(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlockHeight() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeight(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeight(::grpc::ServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSlot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSlot() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSlot(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSlot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlot(::grpc::ServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSlot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsBlockhashValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsBlockhashValid() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsBlockhashValid(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsBlockhashValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBlockhashValid(::grpc::ServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsBlockhashValid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubscribeReplayInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubscribeReplayInfo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::SubscribeReplayInfoRequest, ::geyser::SubscribeReplayInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::SubscribeReplayInfoRequest, ::geyser::SubscribeReplayInfoResponse>* streamer) {
                       return this->StreamedSubscribeReplayInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubscribeReplayInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeReplayInfo(::grpc::ServerContext* /*context*/, const ::geyser::SubscribeReplayInfoRequest* /*request*/, ::geyser::SubscribeReplayInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubscribeReplayInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::SubscribeReplayInfoRequest,::geyser::SubscribeReplayInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ping() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::PingRequest, ::geyser::PongResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::PingRequest, ::geyser::PongResponse>* streamer) {
                       return this->StreamedPing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::geyser::PingRequest* /*request*/, ::geyser::PongResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::PingRequest,::geyser::PongResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestBlockhash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestBlockhash() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::GetLatestBlockhashRequest, ::geyser::GetLatestBlockhashResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::GetLatestBlockhashRequest, ::geyser::GetLatestBlockhashResponse>* streamer) {
                       return this->StreamedGetLatestBlockhash(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestBlockhash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestBlockhash(::grpc::ServerContext* /*context*/, const ::geyser::GetLatestBlockhashRequest* /*request*/, ::geyser::GetLatestBlockhashResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestBlockhash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::GetLatestBlockhashRequest,::geyser::GetLatestBlockhashResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::GetBlockHeightRequest, ::geyser::GetBlockHeightResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::GetBlockHeightRequest, ::geyser::GetBlockHeightResponse>* streamer) {
                       return this->StreamedGetBlockHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeight(::grpc::ServerContext* /*context*/, const ::geyser::GetBlockHeightRequest* /*request*/, ::geyser::GetBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::GetBlockHeightRequest,::geyser::GetBlockHeightResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSlot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSlot() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::GetSlotRequest, ::geyser::GetSlotResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::GetSlotRequest, ::geyser::GetSlotResponse>* streamer) {
                       return this->StreamedGetSlot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSlot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSlot(::grpc::ServerContext* /*context*/, const ::geyser::GetSlotRequest* /*request*/, ::geyser::GetSlotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSlot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::GetSlotRequest,::geyser::GetSlotResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsBlockhashValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsBlockhashValid() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::IsBlockhashValidRequest, ::geyser::IsBlockhashValidResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::IsBlockhashValidRequest, ::geyser::IsBlockhashValidResponse>* streamer) {
                       return this->StreamedIsBlockhashValid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsBlockhashValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsBlockhashValid(::grpc::ServerContext* /*context*/, const ::geyser::IsBlockhashValidRequest* /*request*/, ::geyser::IsBlockhashValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsBlockhashValid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::IsBlockhashValidRequest,::geyser::IsBlockhashValidResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::geyser::GetVersionRequest, ::geyser::GetVersionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::geyser::GetVersionRequest, ::geyser::GetVersionResponse>* streamer) {
                       return this->StreamedGetVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::geyser::GetVersionRequest* /*request*/, ::geyser::GetVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::geyser::GetVersionRequest,::geyser::GetVersionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SubscribeReplayInfo<WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetLatestBlockhash<WithStreamedUnaryMethod_GetBlockHeight<WithStreamedUnaryMethod_GetSlot<WithStreamedUnaryMethod_IsBlockhashValid<WithStreamedUnaryMethod_GetVersion<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SubscribeReplayInfo<WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetLatestBlockhash<WithStreamedUnaryMethod_GetBlockHeight<WithStreamedUnaryMethod_GetSlot<WithStreamedUnaryMethod_IsBlockhashValid<WithStreamedUnaryMethod_GetVersion<Service > > > > > > > StreamedService;
};

}  // namespace geyser


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_geyser_2eproto__INCLUDED
