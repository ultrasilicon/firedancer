// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: geyser.proto
// Protobuf C++ Version: 6.31.0

#ifndef geyser_2eproto_2epb_2eh
#define geyser_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "solana-storage.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_geyser_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_geyser_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_geyser_2eproto;
}  // extern "C"
namespace geyser {
enum CommitmentLevel : int;
extern const uint32_t CommitmentLevel_internal_data_[];
enum SlotStatus : int;
extern const uint32_t SlotStatus_internal_data_[];
class GetBlockHeightRequest;
struct GetBlockHeightRequestDefaultTypeInternal;
extern GetBlockHeightRequestDefaultTypeInternal _GetBlockHeightRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetBlockHeightRequest_class_data_;
class GetBlockHeightResponse;
struct GetBlockHeightResponseDefaultTypeInternal;
extern GetBlockHeightResponseDefaultTypeInternal _GetBlockHeightResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetBlockHeightResponse_class_data_;
class GetLatestBlockhashRequest;
struct GetLatestBlockhashRequestDefaultTypeInternal;
extern GetLatestBlockhashRequestDefaultTypeInternal _GetLatestBlockhashRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetLatestBlockhashRequest_class_data_;
class GetLatestBlockhashResponse;
struct GetLatestBlockhashResponseDefaultTypeInternal;
extern GetLatestBlockhashResponseDefaultTypeInternal _GetLatestBlockhashResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetLatestBlockhashResponse_class_data_;
class GetSlotRequest;
struct GetSlotRequestDefaultTypeInternal;
extern GetSlotRequestDefaultTypeInternal _GetSlotRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetSlotRequest_class_data_;
class GetSlotResponse;
struct GetSlotResponseDefaultTypeInternal;
extern GetSlotResponseDefaultTypeInternal _GetSlotResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetSlotResponse_class_data_;
class GetVersionRequest;
struct GetVersionRequestDefaultTypeInternal;
extern GetVersionRequestDefaultTypeInternal _GetVersionRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetVersionRequest_class_data_;
class GetVersionResponse;
struct GetVersionResponseDefaultTypeInternal;
extern GetVersionResponseDefaultTypeInternal _GetVersionResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetVersionResponse_class_data_;
class IsBlockhashValidRequest;
struct IsBlockhashValidRequestDefaultTypeInternal;
extern IsBlockhashValidRequestDefaultTypeInternal _IsBlockhashValidRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IsBlockhashValidRequest_class_data_;
class IsBlockhashValidResponse;
struct IsBlockhashValidResponseDefaultTypeInternal;
extern IsBlockhashValidResponseDefaultTypeInternal _IsBlockhashValidResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IsBlockhashValidResponse_class_data_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PingRequest_class_data_;
class PongResponse;
struct PongResponseDefaultTypeInternal;
extern PongResponseDefaultTypeInternal _PongResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PongResponse_class_data_;
class SubscribeReplayInfoRequest;
struct SubscribeReplayInfoRequestDefaultTypeInternal;
extern SubscribeReplayInfoRequestDefaultTypeInternal _SubscribeReplayInfoRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeReplayInfoRequest_class_data_;
class SubscribeReplayInfoResponse;
struct SubscribeReplayInfoResponseDefaultTypeInternal;
extern SubscribeReplayInfoResponseDefaultTypeInternal _SubscribeReplayInfoResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeReplayInfoResponse_class_data_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_class_data_;
class SubscribeRequestAccountsDataSlice;
struct SubscribeRequestAccountsDataSliceDefaultTypeInternal;
extern SubscribeRequestAccountsDataSliceDefaultTypeInternal _SubscribeRequestAccountsDataSlice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestAccountsDataSlice_class_data_;
class SubscribeRequestFilterAccounts;
struct SubscribeRequestFilterAccountsDefaultTypeInternal;
extern SubscribeRequestFilterAccountsDefaultTypeInternal _SubscribeRequestFilterAccounts_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccounts_class_data_;
class SubscribeRequestFilterAccountsFilter;
struct SubscribeRequestFilterAccountsFilterDefaultTypeInternal;
extern SubscribeRequestFilterAccountsFilterDefaultTypeInternal _SubscribeRequestFilterAccountsFilter_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccountsFilter_class_data_;
class SubscribeRequestFilterAccountsFilterLamports;
struct SubscribeRequestFilterAccountsFilterLamportsDefaultTypeInternal;
extern SubscribeRequestFilterAccountsFilterLamportsDefaultTypeInternal _SubscribeRequestFilterAccountsFilterLamports_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccountsFilterLamports_class_data_;
class SubscribeRequestFilterAccountsFilterMemcmp;
struct SubscribeRequestFilterAccountsFilterMemcmpDefaultTypeInternal;
extern SubscribeRequestFilterAccountsFilterMemcmpDefaultTypeInternal _SubscribeRequestFilterAccountsFilterMemcmp_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccountsFilterMemcmp_class_data_;
class SubscribeRequestFilterBlocks;
struct SubscribeRequestFilterBlocksDefaultTypeInternal;
extern SubscribeRequestFilterBlocksDefaultTypeInternal _SubscribeRequestFilterBlocks_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterBlocks_class_data_;
class SubscribeRequestFilterBlocksMeta;
struct SubscribeRequestFilterBlocksMetaDefaultTypeInternal;
extern SubscribeRequestFilterBlocksMetaDefaultTypeInternal _SubscribeRequestFilterBlocksMeta_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterBlocksMeta_class_data_;
class SubscribeRequestFilterEntry;
struct SubscribeRequestFilterEntryDefaultTypeInternal;
extern SubscribeRequestFilterEntryDefaultTypeInternal _SubscribeRequestFilterEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterEntry_class_data_;
class SubscribeRequestFilterSlots;
struct SubscribeRequestFilterSlotsDefaultTypeInternal;
extern SubscribeRequestFilterSlotsDefaultTypeInternal _SubscribeRequestFilterSlots_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterSlots_class_data_;
class SubscribeRequestFilterTransactions;
struct SubscribeRequestFilterTransactionsDefaultTypeInternal;
extern SubscribeRequestFilterTransactionsDefaultTypeInternal _SubscribeRequestFilterTransactions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterTransactions_class_data_;
class SubscribeRequestPing;
struct SubscribeRequestPingDefaultTypeInternal;
extern SubscribeRequestPingDefaultTypeInternal _SubscribeRequestPing_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestPing_class_data_;
class SubscribeRequest_AccountsEntry_DoNotUse;
struct SubscribeRequest_AccountsEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_AccountsEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_AccountsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_AccountsEntry_DoNotUse_class_data_;
class SubscribeRequest_BlocksEntry_DoNotUse;
struct SubscribeRequest_BlocksEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_BlocksEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_BlocksEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_BlocksEntry_DoNotUse_class_data_;
class SubscribeRequest_BlocksMetaEntry_DoNotUse;
struct SubscribeRequest_BlocksMetaEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_BlocksMetaEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_BlocksMetaEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_BlocksMetaEntry_DoNotUse_class_data_;
class SubscribeRequest_EntryEntry_DoNotUse;
struct SubscribeRequest_EntryEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_EntryEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_EntryEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_EntryEntry_DoNotUse_class_data_;
class SubscribeRequest_SlotsEntry_DoNotUse;
struct SubscribeRequest_SlotsEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_SlotsEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_SlotsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_SlotsEntry_DoNotUse_class_data_;
class SubscribeRequest_TransactionsEntry_DoNotUse;
struct SubscribeRequest_TransactionsEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_TransactionsEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_TransactionsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_TransactionsEntry_DoNotUse_class_data_;
class SubscribeRequest_TransactionsStatusEntry_DoNotUse;
struct SubscribeRequest_TransactionsStatusEntry_DoNotUseDefaultTypeInternal;
extern SubscribeRequest_TransactionsStatusEntry_DoNotUseDefaultTypeInternal _SubscribeRequest_TransactionsStatusEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_TransactionsStatusEntry_DoNotUse_class_data_;
class SubscribeUpdate;
struct SubscribeUpdateDefaultTypeInternal;
extern SubscribeUpdateDefaultTypeInternal _SubscribeUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdate_class_data_;
class SubscribeUpdateAccount;
struct SubscribeUpdateAccountDefaultTypeInternal;
extern SubscribeUpdateAccountDefaultTypeInternal _SubscribeUpdateAccount_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateAccount_class_data_;
class SubscribeUpdateAccountInfo;
struct SubscribeUpdateAccountInfoDefaultTypeInternal;
extern SubscribeUpdateAccountInfoDefaultTypeInternal _SubscribeUpdateAccountInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateAccountInfo_class_data_;
class SubscribeUpdateBlock;
struct SubscribeUpdateBlockDefaultTypeInternal;
extern SubscribeUpdateBlockDefaultTypeInternal _SubscribeUpdateBlock_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateBlock_class_data_;
class SubscribeUpdateBlockMeta;
struct SubscribeUpdateBlockMetaDefaultTypeInternal;
extern SubscribeUpdateBlockMetaDefaultTypeInternal _SubscribeUpdateBlockMeta_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateBlockMeta_class_data_;
class SubscribeUpdateEntry;
struct SubscribeUpdateEntryDefaultTypeInternal;
extern SubscribeUpdateEntryDefaultTypeInternal _SubscribeUpdateEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateEntry_class_data_;
class SubscribeUpdatePing;
struct SubscribeUpdatePingDefaultTypeInternal;
extern SubscribeUpdatePingDefaultTypeInternal _SubscribeUpdatePing_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdatePing_class_data_;
class SubscribeUpdatePong;
struct SubscribeUpdatePongDefaultTypeInternal;
extern SubscribeUpdatePongDefaultTypeInternal _SubscribeUpdatePong_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdatePong_class_data_;
class SubscribeUpdateSlot;
struct SubscribeUpdateSlotDefaultTypeInternal;
extern SubscribeUpdateSlotDefaultTypeInternal _SubscribeUpdateSlot_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateSlot_class_data_;
class SubscribeUpdateTransaction;
struct SubscribeUpdateTransactionDefaultTypeInternal;
extern SubscribeUpdateTransactionDefaultTypeInternal _SubscribeUpdateTransaction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateTransaction_class_data_;
class SubscribeUpdateTransactionInfo;
struct SubscribeUpdateTransactionInfoDefaultTypeInternal;
extern SubscribeUpdateTransactionInfoDefaultTypeInternal _SubscribeUpdateTransactionInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateTransactionInfo_class_data_;
class SubscribeUpdateTransactionStatus;
struct SubscribeUpdateTransactionStatusDefaultTypeInternal;
extern SubscribeUpdateTransactionStatusDefaultTypeInternal _SubscribeUpdateTransactionStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateTransactionStatus_class_data_;
}  // namespace geyser
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::geyser::CommitmentLevel_internal_data_>
    internal::EnumTraitsImpl::value<::geyser::CommitmentLevel>;
template <>
internal::EnumTraitsT<::geyser::SlotStatus_internal_data_>
    internal::EnumTraitsImpl::value<::geyser::SlotStatus>;
}  // namespace protobuf
}  // namespace google

namespace geyser {
enum CommitmentLevel : int {
  PROCESSED = 0,
  CONFIRMED = 1,
  FINALIZED = 2,
  CommitmentLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CommitmentLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CommitmentLevel_internal_data_[];
inline constexpr CommitmentLevel CommitmentLevel_MIN =
    static_cast<CommitmentLevel>(0);
inline constexpr CommitmentLevel CommitmentLevel_MAX =
    static_cast<CommitmentLevel>(2);
inline bool CommitmentLevel_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int CommitmentLevel_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CommitmentLevel_descriptor();
template <typename T>
const ::std::string& CommitmentLevel_Name(T value) {
  static_assert(::std::is_same<T, CommitmentLevel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CommitmentLevel_Name().");
  return CommitmentLevel_Name(static_cast<CommitmentLevel>(value));
}
template <>
inline const ::std::string& CommitmentLevel_Name(CommitmentLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommitmentLevel_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool CommitmentLevel_Parse(
    ::absl::string_view name, CommitmentLevel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommitmentLevel>(CommitmentLevel_descriptor(), name,
                                           value);
}
enum SlotStatus : int {
  SLOT_PROCESSED = 0,
  SLOT_CONFIRMED = 1,
  SLOT_FINALIZED = 2,
  SLOT_FIRST_SHRED_RECEIVED = 3,
  SLOT_COMPLETED = 4,
  SLOT_CREATED_BANK = 5,
  SLOT_DEAD = 6,
  SlotStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SlotStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SlotStatus_internal_data_[];
inline constexpr SlotStatus SlotStatus_MIN =
    static_cast<SlotStatus>(0);
inline constexpr SlotStatus SlotStatus_MAX =
    static_cast<SlotStatus>(6);
inline bool SlotStatus_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int SlotStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SlotStatus_descriptor();
template <typename T>
const ::std::string& SlotStatus_Name(T value) {
  static_assert(::std::is_same<T, SlotStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SlotStatus_Name().");
  return SlotStatus_Name(static_cast<SlotStatus>(value));
}
template <>
inline const ::std::string& SlotStatus_Name(SlotStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SlotStatus_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool SlotStatus_Parse(
    ::absl::string_view name, SlotStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlotStatus>(SlotStatus_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class SubscribeUpdateSlot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateSlot) */ {
 public:
  inline SubscribeUpdateSlot() : SubscribeUpdateSlot(nullptr) {}
  ~SubscribeUpdateSlot() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateSlot* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateSlot));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateSlot(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateSlot(const SubscribeUpdateSlot& from) : SubscribeUpdateSlot(nullptr, from) {}
  inline SubscribeUpdateSlot(SubscribeUpdateSlot&& from) noexcept
      : SubscribeUpdateSlot(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateSlot& operator=(const SubscribeUpdateSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateSlot& operator=(SubscribeUpdateSlot&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateSlot& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateSlot*>(
        &_SubscribeUpdateSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(SubscribeUpdateSlot& a, SubscribeUpdateSlot& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateSlot* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateSlot* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateSlot* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateSlot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateSlot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateSlot& from) { SubscribeUpdateSlot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateSlot* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateSlot"; }

 protected:
  explicit SubscribeUpdateSlot(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateSlot(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateSlot& from);
  SubscribeUpdateSlot(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateSlot&& from) noexcept
      : SubscribeUpdateSlot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeadErrorFieldNumber = 4,
    kSlotFieldNumber = 1,
    kParentFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional string dead_error = 4;
  bool has_dead_error() const;
  void clear_dead_error() ;
  const ::std::string& dead_error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dead_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dead_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dead_error();
  void set_allocated_dead_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dead_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dead_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dead_error();

  public:
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // optional uint64 parent = 2;
  bool has_parent() const;
  void clear_parent() ;
  ::uint64_t parent() const;
  void set_parent(::uint64_t value);

  private:
  ::uint64_t _internal_parent() const;
  void _internal_set_parent(::uint64_t value);

  public:
  // .geyser.SlotStatus status = 3;
  void clear_status() ;
  ::geyser::SlotStatus status() const;
  void set_status(::geyser::SlotStatus value);

  private:
  ::geyser::SlotStatus _internal_status() const;
  void _internal_set_status(::geyser::SlotStatus value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateSlot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateSlot& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dead_error_;
    ::uint64_t slot_;
    ::uint64_t parent_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateSlot_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdatePong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdatePong) */ {
 public:
  inline SubscribeUpdatePong() : SubscribeUpdatePong(nullptr) {}
  ~SubscribeUpdatePong() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdatePong* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdatePong));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdatePong(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdatePong(const SubscribeUpdatePong& from) : SubscribeUpdatePong(nullptr, from) {}
  inline SubscribeUpdatePong(SubscribeUpdatePong&& from) noexcept
      : SubscribeUpdatePong(nullptr, ::std::move(from)) {}
  inline SubscribeUpdatePong& operator=(const SubscribeUpdatePong& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdatePong& operator=(SubscribeUpdatePong&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdatePong& default_instance() {
    return *reinterpret_cast<const SubscribeUpdatePong*>(
        &_SubscribeUpdatePong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(SubscribeUpdatePong& a, SubscribeUpdatePong& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdatePong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdatePong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdatePong* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdatePong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdatePong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdatePong& from) { SubscribeUpdatePong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdatePong* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdatePong"; }

 protected:
  explicit SubscribeUpdatePong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdatePong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdatePong& from);
  SubscribeUpdatePong(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdatePong&& from) noexcept
      : SubscribeUpdatePong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdatePong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdatePong& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdatePong_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdatePing final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdatePing) */ {
 public:
  inline SubscribeUpdatePing() : SubscribeUpdatePing(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdatePing* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdatePing));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdatePing(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdatePing(const SubscribeUpdatePing& from) : SubscribeUpdatePing(nullptr, from) {}
  inline SubscribeUpdatePing(SubscribeUpdatePing&& from) noexcept
      : SubscribeUpdatePing(nullptr, ::std::move(from)) {}
  inline SubscribeUpdatePing& operator=(const SubscribeUpdatePing& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdatePing& operator=(SubscribeUpdatePing&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdatePing& default_instance() {
    return *reinterpret_cast<const SubscribeUpdatePing*>(
        &_SubscribeUpdatePing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(SubscribeUpdatePing& a, SubscribeUpdatePing& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdatePing* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdatePing* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdatePing* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SubscribeUpdatePing>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeUpdatePing& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeUpdatePing& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdatePing"; }

 protected:
  explicit SubscribeUpdatePing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdatePing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdatePing& from);
  SubscribeUpdatePing(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdatePing&& from) noexcept
      : SubscribeUpdatePing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdatePing)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdatePing& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdatePing_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateEntry) */ {
 public:
  inline SubscribeUpdateEntry() : SubscribeUpdateEntry(nullptr) {}
  ~SubscribeUpdateEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateEntry* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateEntry(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateEntry(const SubscribeUpdateEntry& from) : SubscribeUpdateEntry(nullptr, from) {}
  inline SubscribeUpdateEntry(SubscribeUpdateEntry&& from) noexcept
      : SubscribeUpdateEntry(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateEntry& operator=(const SubscribeUpdateEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateEntry& operator=(SubscribeUpdateEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateEntry& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateEntry*>(
        &_SubscribeUpdateEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(SubscribeUpdateEntry& a, SubscribeUpdateEntry& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateEntry& from) { SubscribeUpdateEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateEntry"; }

 protected:
  explicit SubscribeUpdateEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateEntry& from);
  SubscribeUpdateEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateEntry&& from) noexcept
      : SubscribeUpdateEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashFieldNumber = 4,
    kSlotFieldNumber = 1,
    kIndexFieldNumber = 2,
    kNumHashesFieldNumber = 3,
    kExecutedTransactionCountFieldNumber = 5,
    kStartingTransactionIndexFieldNumber = 6,
  };
  // bytes hash = 4;
  void clear_hash() ;
  const ::std::string& hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hash();
  void set_allocated_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hash();

  public:
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // uint64 index = 2;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // uint64 num_hashes = 3;
  void clear_num_hashes() ;
  ::uint64_t num_hashes() const;
  void set_num_hashes(::uint64_t value);

  private:
  ::uint64_t _internal_num_hashes() const;
  void _internal_set_num_hashes(::uint64_t value);

  public:
  // uint64 executed_transaction_count = 5;
  void clear_executed_transaction_count() ;
  ::uint64_t executed_transaction_count() const;
  void set_executed_transaction_count(::uint64_t value);

  private:
  ::uint64_t _internal_executed_transaction_count() const;
  void _internal_set_executed_transaction_count(::uint64_t value);

  public:
  // uint64 starting_transaction_index = 6;
  void clear_starting_transaction_index() ;
  ::uint64_t starting_transaction_index() const;
  void set_starting_transaction_index(::uint64_t value);

  private:
  ::uint64_t _internal_starting_transaction_index() const;
  void _internal_set_starting_transaction_index(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::uint64_t slot_;
    ::uint64_t index_;
    ::uint64_t num_hashes_;
    ::uint64_t executed_transaction_count_;
    ::uint64_t starting_transaction_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateEntry_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateAccountInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateAccountInfo) */ {
 public:
  inline SubscribeUpdateAccountInfo() : SubscribeUpdateAccountInfo(nullptr) {}
  ~SubscribeUpdateAccountInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateAccountInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateAccountInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateAccountInfo(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateAccountInfo(const SubscribeUpdateAccountInfo& from) : SubscribeUpdateAccountInfo(nullptr, from) {}
  inline SubscribeUpdateAccountInfo(SubscribeUpdateAccountInfo&& from) noexcept
      : SubscribeUpdateAccountInfo(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateAccountInfo& operator=(const SubscribeUpdateAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateAccountInfo& operator=(SubscribeUpdateAccountInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateAccountInfo& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateAccountInfo*>(
        &_SubscribeUpdateAccountInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(SubscribeUpdateAccountInfo& a, SubscribeUpdateAccountInfo& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateAccountInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateAccountInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateAccountInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateAccountInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateAccountInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateAccountInfo& from) { SubscribeUpdateAccountInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateAccountInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateAccountInfo"; }

 protected:
  explicit SubscribeUpdateAccountInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateAccountInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateAccountInfo& from);
  SubscribeUpdateAccountInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateAccountInfo&& from) noexcept
      : SubscribeUpdateAccountInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPubkeyFieldNumber = 1,
    kOwnerFieldNumber = 3,
    kDataFieldNumber = 6,
    kTxnSignatureFieldNumber = 8,
    kLamportsFieldNumber = 2,
    kRentEpochFieldNumber = 5,
    kWriteVersionFieldNumber = 7,
    kExecutableFieldNumber = 4,
  };
  // bytes pubkey = 1;
  void clear_pubkey() ;
  const ::std::string& pubkey() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_pubkey(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_pubkey();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_pubkey();
  void set_allocated_pubkey(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_pubkey() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_pubkey();

  public:
  // bytes owner = 3;
  void clear_owner() ;
  const ::std::string& owner() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_owner();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_owner();
  void set_allocated_owner(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_owner() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_owner();

  public:
  // bytes data = 6;
  void clear_data() ;
  const ::std::string& data() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_data();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_data();
  void set_allocated_data(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_data() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // optional bytes txn_signature = 8;
  bool has_txn_signature() const;
  void clear_txn_signature() ;
  const ::std::string& txn_signature() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_txn_signature(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_txn_signature();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_txn_signature();
  void set_allocated_txn_signature(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_txn_signature() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_txn_signature(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_txn_signature();

  public:
  // uint64 lamports = 2;
  void clear_lamports() ;
  ::uint64_t lamports() const;
  void set_lamports(::uint64_t value);

  private:
  ::uint64_t _internal_lamports() const;
  void _internal_set_lamports(::uint64_t value);

  public:
  // uint64 rent_epoch = 5;
  void clear_rent_epoch() ;
  ::uint64_t rent_epoch() const;
  void set_rent_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_rent_epoch() const;
  void _internal_set_rent_epoch(::uint64_t value);

  public:
  // uint64 write_version = 7;
  void clear_write_version() ;
  ::uint64_t write_version() const;
  void set_write_version(::uint64_t value);

  private:
  ::uint64_t _internal_write_version() const;
  void _internal_set_write_version(::uint64_t value);

  public:
  // bool executable = 4;
  void clear_executable() ;
  bool executable() const;
  void set_executable(bool value);

  private:
  bool _internal_executable() const;
  void _internal_set_executable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateAccountInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateAccountInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr pubkey_;
    ::google::protobuf::internal::ArenaStringPtr owner_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr txn_signature_;
    ::uint64_t lamports_;
    ::uint64_t rent_epoch_;
    ::uint64_t write_version_;
    bool executable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateAccountInfo_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestPing final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestPing) */ {
 public:
  inline SubscribeRequestPing() : SubscribeRequestPing(nullptr) {}
  ~SubscribeRequestPing() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestPing* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestPing));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestPing(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestPing(const SubscribeRequestPing& from) : SubscribeRequestPing(nullptr, from) {}
  inline SubscribeRequestPing(SubscribeRequestPing&& from) noexcept
      : SubscribeRequestPing(nullptr, ::std::move(from)) {}
  inline SubscribeRequestPing& operator=(const SubscribeRequestPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestPing& operator=(SubscribeRequestPing&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestPing& default_instance() {
    return *reinterpret_cast<const SubscribeRequestPing*>(
        &_SubscribeRequestPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SubscribeRequestPing& a, SubscribeRequestPing& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestPing* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestPing* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestPing* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestPing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestPing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestPing& from) { SubscribeRequestPing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestPing* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestPing"; }

 protected:
  explicit SubscribeRequestPing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestPing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestPing& from);
  SubscribeRequestPing(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestPing&& from) noexcept
      : SubscribeRequestPing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestPing)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestPing& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestPing_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterTransactions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterTransactions) */ {
 public:
  inline SubscribeRequestFilterTransactions() : SubscribeRequestFilterTransactions(nullptr) {}
  ~SubscribeRequestFilterTransactions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterTransactions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterTransactions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterTransactions(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterTransactions(const SubscribeRequestFilterTransactions& from) : SubscribeRequestFilterTransactions(nullptr, from) {}
  inline SubscribeRequestFilterTransactions(SubscribeRequestFilterTransactions&& from) noexcept
      : SubscribeRequestFilterTransactions(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterTransactions& operator=(const SubscribeRequestFilterTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterTransactions& operator=(SubscribeRequestFilterTransactions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterTransactions& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterTransactions*>(
        &_SubscribeRequestFilterTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SubscribeRequestFilterTransactions& a, SubscribeRequestFilterTransactions& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterTransactions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterTransactions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterTransactions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterTransactions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterTransactions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterTransactions& from) { SubscribeRequestFilterTransactions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterTransactions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterTransactions"; }

 protected:
  explicit SubscribeRequestFilterTransactions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterTransactions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterTransactions& from);
  SubscribeRequestFilterTransactions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterTransactions&& from) noexcept
      : SubscribeRequestFilterTransactions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountIncludeFieldNumber = 3,
    kAccountExcludeFieldNumber = 4,
    kAccountRequiredFieldNumber = 6,
    kSignatureFieldNumber = 5,
    kVoteFieldNumber = 1,
    kFailedFieldNumber = 2,
  };
  // repeated string account_include = 3;
  int account_include_size() const;
  private:
  int _internal_account_include_size() const;

  public:
  void clear_account_include() ;
  const ::std::string& account_include(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_account_include(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account_include(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_account_include();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_account_include(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& account_include() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_account_include();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_account_include() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_account_include();

  public:
  // repeated string account_exclude = 4;
  int account_exclude_size() const;
  private:
  int _internal_account_exclude_size() const;

  public:
  void clear_account_exclude() ;
  const ::std::string& account_exclude(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_account_exclude(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account_exclude(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_account_exclude();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_account_exclude(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& account_exclude() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_account_exclude();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_account_exclude() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_account_exclude();

  public:
  // repeated string account_required = 6;
  int account_required_size() const;
  private:
  int _internal_account_required_size() const;

  public:
  void clear_account_required() ;
  const ::std::string& account_required(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_account_required(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account_required(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_account_required();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_account_required(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& account_required() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_account_required();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_account_required() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_account_required();

  public:
  // optional string signature = 5;
  bool has_signature() const;
  void clear_signature() ;
  const ::std::string& signature() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_signature();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_signature();
  void set_allocated_signature(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_signature() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_signature();

  public:
  // optional bool vote = 1;
  bool has_vote() const;
  void clear_vote() ;
  bool vote() const;
  void set_vote(bool value);

  private:
  bool _internal_vote() const;
  void _internal_set_vote(bool value);

  public:
  // optional bool failed = 2;
  bool has_failed() const;
  void clear_failed() ;
  bool failed() const;
  void set_failed(bool value);

  private:
  bool _internal_failed() const;
  void _internal_set_failed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterTransactions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 105,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterTransactions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> account_include_;
    ::google::protobuf::RepeatedPtrField<::std::string> account_exclude_;
    ::google::protobuf::RepeatedPtrField<::std::string> account_required_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    bool vote_;
    bool failed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterTransactions_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterSlots final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterSlots) */ {
 public:
  inline SubscribeRequestFilterSlots() : SubscribeRequestFilterSlots(nullptr) {}
  ~SubscribeRequestFilterSlots() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterSlots* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterSlots));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterSlots(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterSlots(const SubscribeRequestFilterSlots& from) : SubscribeRequestFilterSlots(nullptr, from) {}
  inline SubscribeRequestFilterSlots(SubscribeRequestFilterSlots&& from) noexcept
      : SubscribeRequestFilterSlots(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterSlots& operator=(const SubscribeRequestFilterSlots& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterSlots& operator=(SubscribeRequestFilterSlots&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterSlots& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterSlots*>(
        &_SubscribeRequestFilterSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SubscribeRequestFilterSlots& a, SubscribeRequestFilterSlots& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterSlots* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterSlots* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterSlots* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterSlots>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterSlots& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterSlots& from) { SubscribeRequestFilterSlots::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterSlots* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterSlots"; }

 protected:
  explicit SubscribeRequestFilterSlots(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterSlots(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterSlots& from);
  SubscribeRequestFilterSlots(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterSlots&& from) noexcept
      : SubscribeRequestFilterSlots(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilterByCommitmentFieldNumber = 1,
    kInterslotUpdatesFieldNumber = 2,
  };
  // optional bool filter_by_commitment = 1;
  bool has_filter_by_commitment() const;
  void clear_filter_by_commitment() ;
  bool filter_by_commitment() const;
  void set_filter_by_commitment(bool value);

  private:
  bool _internal_filter_by_commitment() const;
  void _internal_set_filter_by_commitment(bool value);

  public:
  // optional bool interslot_updates = 2;
  bool has_interslot_updates() const;
  void clear_interslot_updates() ;
  bool interslot_updates() const;
  void set_interslot_updates(bool value);

  private:
  bool _internal_interslot_updates() const;
  void _internal_set_interslot_updates(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterSlots)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterSlots& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool filter_by_commitment_;
    bool interslot_updates_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterSlots_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterEntry final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterEntry) */ {
 public:
  inline SubscribeRequestFilterEntry() : SubscribeRequestFilterEntry(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterEntry* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterEntry(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterEntry(const SubscribeRequestFilterEntry& from) : SubscribeRequestFilterEntry(nullptr, from) {}
  inline SubscribeRequestFilterEntry(SubscribeRequestFilterEntry&& from) noexcept
      : SubscribeRequestFilterEntry(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterEntry& operator=(const SubscribeRequestFilterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterEntry& operator=(SubscribeRequestFilterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterEntry& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterEntry*>(
        &_SubscribeRequestFilterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SubscribeRequestFilterEntry& a, SubscribeRequestFilterEntry& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SubscribeRequestFilterEntry>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeRequestFilterEntry& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterEntry& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterEntry"; }

 protected:
  explicit SubscribeRequestFilterEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterEntry& from);
  SubscribeRequestFilterEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterEntry&& from) noexcept
      : SubscribeRequestFilterEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterEntry& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterEntry_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterBlocksMeta final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterBlocksMeta) */ {
 public:
  inline SubscribeRequestFilterBlocksMeta() : SubscribeRequestFilterBlocksMeta(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterBlocksMeta* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterBlocksMeta));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterBlocksMeta(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterBlocksMeta(const SubscribeRequestFilterBlocksMeta& from) : SubscribeRequestFilterBlocksMeta(nullptr, from) {}
  inline SubscribeRequestFilterBlocksMeta(SubscribeRequestFilterBlocksMeta&& from) noexcept
      : SubscribeRequestFilterBlocksMeta(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterBlocksMeta& operator=(const SubscribeRequestFilterBlocksMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterBlocksMeta& operator=(SubscribeRequestFilterBlocksMeta&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterBlocksMeta& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterBlocksMeta*>(
        &_SubscribeRequestFilterBlocksMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SubscribeRequestFilterBlocksMeta& a, SubscribeRequestFilterBlocksMeta& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterBlocksMeta* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterBlocksMeta* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterBlocksMeta* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SubscribeRequestFilterBlocksMeta>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeRequestFilterBlocksMeta& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterBlocksMeta& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterBlocksMeta"; }

 protected:
  explicit SubscribeRequestFilterBlocksMeta(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterBlocksMeta(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterBlocksMeta& from);
  SubscribeRequestFilterBlocksMeta(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterBlocksMeta&& from) noexcept
      : SubscribeRequestFilterBlocksMeta(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterBlocksMeta)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterBlocksMeta& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterBlocksMeta_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterBlocks final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterBlocks) */ {
 public:
  inline SubscribeRequestFilterBlocks() : SubscribeRequestFilterBlocks(nullptr) {}
  ~SubscribeRequestFilterBlocks() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterBlocks* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterBlocks));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterBlocks(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterBlocks(const SubscribeRequestFilterBlocks& from) : SubscribeRequestFilterBlocks(nullptr, from) {}
  inline SubscribeRequestFilterBlocks(SubscribeRequestFilterBlocks&& from) noexcept
      : SubscribeRequestFilterBlocks(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterBlocks& operator=(const SubscribeRequestFilterBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterBlocks& operator=(SubscribeRequestFilterBlocks&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterBlocks& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterBlocks*>(
        &_SubscribeRequestFilterBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SubscribeRequestFilterBlocks& a, SubscribeRequestFilterBlocks& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterBlocks* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterBlocks* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterBlocks* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterBlocks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterBlocks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterBlocks& from) { SubscribeRequestFilterBlocks::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterBlocks* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterBlocks"; }

 protected:
  explicit SubscribeRequestFilterBlocks(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterBlocks(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterBlocks& from);
  SubscribeRequestFilterBlocks(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterBlocks&& from) noexcept
      : SubscribeRequestFilterBlocks(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountIncludeFieldNumber = 1,
    kIncludeTransactionsFieldNumber = 2,
    kIncludeAccountsFieldNumber = 3,
    kIncludeEntriesFieldNumber = 4,
  };
  // repeated string account_include = 1;
  int account_include_size() const;
  private:
  int _internal_account_include_size() const;

  public:
  void clear_account_include() ;
  const ::std::string& account_include(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_account_include(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account_include(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_account_include();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_account_include(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& account_include() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_account_include();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_account_include() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_account_include();

  public:
  // optional bool include_transactions = 2;
  bool has_include_transactions() const;
  void clear_include_transactions() ;
  bool include_transactions() const;
  void set_include_transactions(bool value);

  private:
  bool _internal_include_transactions() const;
  void _internal_set_include_transactions(bool value);

  public:
  // optional bool include_accounts = 3;
  bool has_include_accounts() const;
  void clear_include_accounts() ;
  bool include_accounts() const;
  void set_include_accounts(bool value);

  private:
  bool _internal_include_accounts() const;
  void _internal_set_include_accounts(bool value);

  public:
  // optional bool include_entries = 4;
  bool has_include_entries() const;
  void clear_include_entries() ;
  bool include_entries() const;
  void set_include_entries(bool value);

  private:
  bool _internal_include_entries() const;
  void _internal_set_include_entries(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterBlocks)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterBlocks& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> account_include_;
    bool include_transactions_;
    bool include_accounts_;
    bool include_entries_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterBlocks_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterAccountsFilterMemcmp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterAccountsFilterMemcmp) */ {
 public:
  inline SubscribeRequestFilterAccountsFilterMemcmp() : SubscribeRequestFilterAccountsFilterMemcmp(nullptr) {}
  ~SubscribeRequestFilterAccountsFilterMemcmp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterAccountsFilterMemcmp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterAccountsFilterMemcmp(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterAccountsFilterMemcmp(const SubscribeRequestFilterAccountsFilterMemcmp& from) : SubscribeRequestFilterAccountsFilterMemcmp(nullptr, from) {}
  inline SubscribeRequestFilterAccountsFilterMemcmp(SubscribeRequestFilterAccountsFilterMemcmp&& from) noexcept
      : SubscribeRequestFilterAccountsFilterMemcmp(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterAccountsFilterMemcmp& operator=(const SubscribeRequestFilterAccountsFilterMemcmp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterAccountsFilterMemcmp& operator=(SubscribeRequestFilterAccountsFilterMemcmp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterAccountsFilterMemcmp& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterAccountsFilterMemcmp*>(
        &_SubscribeRequestFilterAccountsFilterMemcmp_default_instance_);
  }
  enum DataCase {
    kBytes = 2,
    kBase58 = 3,
    kBase64 = 4,
    DATA_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SubscribeRequestFilterAccountsFilterMemcmp& a, SubscribeRequestFilterAccountsFilterMemcmp& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterAccountsFilterMemcmp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterAccountsFilterMemcmp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterAccountsFilterMemcmp& from) { SubscribeRequestFilterAccountsFilterMemcmp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterAccountsFilterMemcmp"; }

 protected:
  explicit SubscribeRequestFilterAccountsFilterMemcmp(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterAccountsFilterMemcmp(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterAccountsFilterMemcmp& from);
  SubscribeRequestFilterAccountsFilterMemcmp(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterAccountsFilterMemcmp&& from) noexcept
      : SubscribeRequestFilterAccountsFilterMemcmp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetFieldNumber = 1,
    kBytesFieldNumber = 2,
    kBase58FieldNumber = 3,
    kBase64FieldNumber = 4,
  };
  // uint64 offset = 1;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // bytes bytes = 2;
  bool has_bytes() const;
  void clear_bytes() ;
  const ::std::string& bytes() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_bytes(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_bytes();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_bytes();
  void set_allocated_bytes(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_bytes() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_bytes(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_bytes();

  public:
  // string base58 = 3;
  bool has_base58() const;
  void clear_base58() ;
  const ::std::string& base58() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_base58(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_base58();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_base58();
  void set_allocated_base58(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_base58() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_base58(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_base58();

  public:
  // string base64 = 4;
  bool has_base64() const;
  void clear_base64() ;
  const ::std::string& base64() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_base64(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_base64();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_base64();
  void set_allocated_base64(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_base64() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_base64(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_base64();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterAccountsFilterMemcmp)
 private:
  class _Internal;
  void set_has_bytes();
  void set_has_base58();
  void set_has_base64();
  inline bool has_data() const;
  inline void clear_has_data();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   0, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterAccountsFilterMemcmp& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t offset_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr bytes_;
      ::google::protobuf::internal::ArenaStringPtr base58_;
      ::google::protobuf::internal::ArenaStringPtr base64_;
    } data_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccountsFilterMemcmp_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterAccountsFilterLamports final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterAccountsFilterLamports) */ {
 public:
  inline SubscribeRequestFilterAccountsFilterLamports() : SubscribeRequestFilterAccountsFilterLamports(nullptr) {}
  ~SubscribeRequestFilterAccountsFilterLamports() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterAccountsFilterLamports));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterAccountsFilterLamports(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterAccountsFilterLamports(const SubscribeRequestFilterAccountsFilterLamports& from) : SubscribeRequestFilterAccountsFilterLamports(nullptr, from) {}
  inline SubscribeRequestFilterAccountsFilterLamports(SubscribeRequestFilterAccountsFilterLamports&& from) noexcept
      : SubscribeRequestFilterAccountsFilterLamports(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterAccountsFilterLamports& operator=(const SubscribeRequestFilterAccountsFilterLamports& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterAccountsFilterLamports& operator=(SubscribeRequestFilterAccountsFilterLamports&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterAccountsFilterLamports& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterAccountsFilterLamports*>(
        &_SubscribeRequestFilterAccountsFilterLamports_default_instance_);
  }
  enum CmpCase {
    kEq = 1,
    kNe = 2,
    kLt = 3,
    kGt = 4,
    CMP_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SubscribeRequestFilterAccountsFilterLamports& a, SubscribeRequestFilterAccountsFilterLamports& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterAccountsFilterLamports>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterAccountsFilterLamports& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterAccountsFilterLamports& from) { SubscribeRequestFilterAccountsFilterLamports::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterAccountsFilterLamports"; }

 protected:
  explicit SubscribeRequestFilterAccountsFilterLamports(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterAccountsFilterLamports(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterAccountsFilterLamports& from);
  SubscribeRequestFilterAccountsFilterLamports(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterAccountsFilterLamports&& from) noexcept
      : SubscribeRequestFilterAccountsFilterLamports(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEqFieldNumber = 1,
    kNeFieldNumber = 2,
    kLtFieldNumber = 3,
    kGtFieldNumber = 4,
  };
  // uint64 eq = 1;
  bool has_eq() const;
  void clear_eq() ;
  ::uint64_t eq() const;
  void set_eq(::uint64_t value);

  private:
  ::uint64_t _internal_eq() const;
  void _internal_set_eq(::uint64_t value);

  public:
  // uint64 ne = 2;
  bool has_ne() const;
  void clear_ne() ;
  ::uint64_t ne() const;
  void set_ne(::uint64_t value);

  private:
  ::uint64_t _internal_ne() const;
  void _internal_set_ne(::uint64_t value);

  public:
  // uint64 lt = 3;
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // uint64 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  void clear_cmp();
  CmpCase cmp_case() const;
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterAccountsFilterLamports)
 private:
  class _Internal;
  void set_has_eq();
  void set_has_ne();
  void set_has_lt();
  void set_has_gt();
  inline bool has_cmp() const;
  inline void clear_has_cmp();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterAccountsFilterLamports& from_msg);
    union CmpUnion {
      constexpr CmpUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t eq_;
      ::uint64_t ne_;
      ::uint64_t lt_;
      ::uint64_t gt_;
    } cmp_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccountsFilterLamports_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestAccountsDataSlice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestAccountsDataSlice) */ {
 public:
  inline SubscribeRequestAccountsDataSlice() : SubscribeRequestAccountsDataSlice(nullptr) {}
  ~SubscribeRequestAccountsDataSlice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestAccountsDataSlice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestAccountsDataSlice(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestAccountsDataSlice(const SubscribeRequestAccountsDataSlice& from) : SubscribeRequestAccountsDataSlice(nullptr, from) {}
  inline SubscribeRequestAccountsDataSlice(SubscribeRequestAccountsDataSlice&& from) noexcept
      : SubscribeRequestAccountsDataSlice(nullptr, ::std::move(from)) {}
  inline SubscribeRequestAccountsDataSlice& operator=(const SubscribeRequestAccountsDataSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestAccountsDataSlice& operator=(SubscribeRequestAccountsDataSlice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestAccountsDataSlice& default_instance() {
    return *reinterpret_cast<const SubscribeRequestAccountsDataSlice*>(
        &_SubscribeRequestAccountsDataSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(SubscribeRequestAccountsDataSlice& a, SubscribeRequestAccountsDataSlice& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestAccountsDataSlice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestAccountsDataSlice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestAccountsDataSlice& from) { SubscribeRequestAccountsDataSlice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestAccountsDataSlice"; }

 protected:
  explicit SubscribeRequestAccountsDataSlice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestAccountsDataSlice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestAccountsDataSlice& from);
  SubscribeRequestAccountsDataSlice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestAccountsDataSlice&& from) noexcept
      : SubscribeRequestAccountsDataSlice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // uint64 offset = 1;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // uint64 length = 2;
  void clear_length() ;
  ::uint64_t length() const;
  void set_length(::uint64_t value);

  private:
  ::uint64_t _internal_length() const;
  void _internal_set_length(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestAccountsDataSlice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestAccountsDataSlice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t offset_;
    ::uint64_t length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestAccountsDataSlice_class_data_;
// -------------------------------------------------------------------

class SubscribeReplayInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeReplayInfoResponse) */ {
 public:
  inline SubscribeReplayInfoResponse() : SubscribeReplayInfoResponse(nullptr) {}
  ~SubscribeReplayInfoResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeReplayInfoResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeReplayInfoResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeReplayInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeReplayInfoResponse(const SubscribeReplayInfoResponse& from) : SubscribeReplayInfoResponse(nullptr, from) {}
  inline SubscribeReplayInfoResponse(SubscribeReplayInfoResponse&& from) noexcept
      : SubscribeReplayInfoResponse(nullptr, ::std::move(from)) {}
  inline SubscribeReplayInfoResponse& operator=(const SubscribeReplayInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReplayInfoResponse& operator=(SubscribeReplayInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeReplayInfoResponse& default_instance() {
    return *reinterpret_cast<const SubscribeReplayInfoResponse*>(
        &_SubscribeReplayInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(SubscribeReplayInfoResponse& a, SubscribeReplayInfoResponse& b) { a.Swap(&b); }
  inline void Swap(SubscribeReplayInfoResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReplayInfoResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeReplayInfoResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeReplayInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeReplayInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeReplayInfoResponse& from) { SubscribeReplayInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeReplayInfoResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeReplayInfoResponse"; }

 protected:
  explicit SubscribeReplayInfoResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeReplayInfoResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeReplayInfoResponse& from);
  SubscribeReplayInfoResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeReplayInfoResponse&& from) noexcept
      : SubscribeReplayInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFirstAvailableFieldNumber = 1,
  };
  // optional uint64 first_available = 1;
  bool has_first_available() const;
  void clear_first_available() ;
  ::uint64_t first_available() const;
  void set_first_available(::uint64_t value);

  private:
  ::uint64_t _internal_first_available() const;
  void _internal_set_first_available(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeReplayInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeReplayInfoResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t first_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeReplayInfoResponse_class_data_;
// -------------------------------------------------------------------

class SubscribeReplayInfoRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:geyser.SubscribeReplayInfoRequest) */ {
 public:
  inline SubscribeReplayInfoRequest() : SubscribeReplayInfoRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeReplayInfoRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeReplayInfoRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeReplayInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeReplayInfoRequest(const SubscribeReplayInfoRequest& from) : SubscribeReplayInfoRequest(nullptr, from) {}
  inline SubscribeReplayInfoRequest(SubscribeReplayInfoRequest&& from) noexcept
      : SubscribeReplayInfoRequest(nullptr, ::std::move(from)) {}
  inline SubscribeReplayInfoRequest& operator=(const SubscribeReplayInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReplayInfoRequest& operator=(SubscribeReplayInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeReplayInfoRequest& default_instance() {
    return *reinterpret_cast<const SubscribeReplayInfoRequest*>(
        &_SubscribeReplayInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(SubscribeReplayInfoRequest& a, SubscribeReplayInfoRequest& b) { a.Swap(&b); }
  inline void Swap(SubscribeReplayInfoRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReplayInfoRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeReplayInfoRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SubscribeReplayInfoRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeReplayInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeReplayInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeReplayInfoRequest"; }

 protected:
  explicit SubscribeReplayInfoRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeReplayInfoRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeReplayInfoRequest& from);
  SubscribeReplayInfoRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeReplayInfoRequest&& from) noexcept
      : SubscribeReplayInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:geyser.SubscribeReplayInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeReplayInfoRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeReplayInfoRequest_class_data_;
// -------------------------------------------------------------------

class PongResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.PongResponse) */ {
 public:
  inline PongResponse() : PongResponse(nullptr) {}
  ~PongResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PongResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PongResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PongResponse(::google::protobuf::internal::ConstantInitialized);

  inline PongResponse(const PongResponse& from) : PongResponse(nullptr, from) {}
  inline PongResponse(PongResponse&& from) noexcept
      : PongResponse(nullptr, ::std::move(from)) {}
  inline PongResponse& operator=(const PongResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PongResponse& operator=(PongResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PongResponse& default_instance() {
    return *reinterpret_cast<const PongResponse*>(
        &_PongResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(PongResponse& a, PongResponse& b) { a.Swap(&b); }
  inline void Swap(PongResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PongResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PongResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PongResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PongResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PongResponse& from) { PongResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PongResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.PongResponse"; }

 protected:
  explicit PongResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PongResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PongResponse& from);
  PongResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PongResponse&& from) noexcept
      : PongResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 count = 1;
  void clear_count() ;
  ::int32_t count() const;
  void set_count(::int32_t value);

  private:
  ::int32_t _internal_count() const;
  void _internal_set_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.PongResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PongResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PongResponse_class_data_;
// -------------------------------------------------------------------

class PingRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PingRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PingRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PingRequest(::google::protobuf::internal::ConstantInitialized);

  inline PingRequest(const PingRequest& from) : PingRequest(nullptr, from) {}
  inline PingRequest(PingRequest&& from) noexcept
      : PingRequest(nullptr, ::std::move(from)) {}
  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *reinterpret_cast<const PingRequest*>(
        &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(PingRequest& a, PingRequest& b) { a.Swap(&b); }
  inline void Swap(PingRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PingRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PingRequest& from) { PingRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PingRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.PingRequest"; }

 protected:
  explicit PingRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PingRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PingRequest& from);
  PingRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PingRequest&& from) noexcept
      : PingRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 count = 1;
  void clear_count() ;
  ::int32_t count() const;
  void set_count(::int32_t value);

  private:
  ::int32_t _internal_count() const;
  void _internal_set_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.PingRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PingRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PingRequest_class_data_;
// -------------------------------------------------------------------

class IsBlockhashValidResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.IsBlockhashValidResponse) */ {
 public:
  inline IsBlockhashValidResponse() : IsBlockhashValidResponse(nullptr) {}
  ~IsBlockhashValidResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IsBlockhashValidResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IsBlockhashValidResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsBlockhashValidResponse(::google::protobuf::internal::ConstantInitialized);

  inline IsBlockhashValidResponse(const IsBlockhashValidResponse& from) : IsBlockhashValidResponse(nullptr, from) {}
  inline IsBlockhashValidResponse(IsBlockhashValidResponse&& from) noexcept
      : IsBlockhashValidResponse(nullptr, ::std::move(from)) {}
  inline IsBlockhashValidResponse& operator=(const IsBlockhashValidResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsBlockhashValidResponse& operator=(IsBlockhashValidResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsBlockhashValidResponse& default_instance() {
    return *reinterpret_cast<const IsBlockhashValidResponse*>(
        &_IsBlockhashValidResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(IsBlockhashValidResponse& a, IsBlockhashValidResponse& b) { a.Swap(&b); }
  inline void Swap(IsBlockhashValidResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsBlockhashValidResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsBlockhashValidResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IsBlockhashValidResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsBlockhashValidResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IsBlockhashValidResponse& from) { IsBlockhashValidResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IsBlockhashValidResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.IsBlockhashValidResponse"; }

 protected:
  explicit IsBlockhashValidResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IsBlockhashValidResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IsBlockhashValidResponse& from);
  IsBlockhashValidResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IsBlockhashValidResponse&& from) noexcept
      : IsBlockhashValidResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSlotFieldNumber = 1,
    kValidFieldNumber = 2,
  };
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // bool valid = 2;
  void clear_valid() ;
  bool valid() const;
  void set_valid(bool value);

  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.IsBlockhashValidResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IsBlockhashValidResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t slot_;
    bool valid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IsBlockhashValidResponse_class_data_;
// -------------------------------------------------------------------

class IsBlockhashValidRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.IsBlockhashValidRequest) */ {
 public:
  inline IsBlockhashValidRequest() : IsBlockhashValidRequest(nullptr) {}
  ~IsBlockhashValidRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IsBlockhashValidRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IsBlockhashValidRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsBlockhashValidRequest(::google::protobuf::internal::ConstantInitialized);

  inline IsBlockhashValidRequest(const IsBlockhashValidRequest& from) : IsBlockhashValidRequest(nullptr, from) {}
  inline IsBlockhashValidRequest(IsBlockhashValidRequest&& from) noexcept
      : IsBlockhashValidRequest(nullptr, ::std::move(from)) {}
  inline IsBlockhashValidRequest& operator=(const IsBlockhashValidRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsBlockhashValidRequest& operator=(IsBlockhashValidRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsBlockhashValidRequest& default_instance() {
    return *reinterpret_cast<const IsBlockhashValidRequest*>(
        &_IsBlockhashValidRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(IsBlockhashValidRequest& a, IsBlockhashValidRequest& b) { a.Swap(&b); }
  inline void Swap(IsBlockhashValidRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsBlockhashValidRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsBlockhashValidRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IsBlockhashValidRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsBlockhashValidRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IsBlockhashValidRequest& from) { IsBlockhashValidRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IsBlockhashValidRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.IsBlockhashValidRequest"; }

 protected:
  explicit IsBlockhashValidRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IsBlockhashValidRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IsBlockhashValidRequest& from);
  IsBlockhashValidRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IsBlockhashValidRequest&& from) noexcept
      : IsBlockhashValidRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockhashFieldNumber = 1,
    kCommitmentFieldNumber = 2,
  };
  // string blockhash = 1;
  void clear_blockhash() ;
  const ::std::string& blockhash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_blockhash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_blockhash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_blockhash();
  void set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_blockhash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_blockhash();

  public:
  // optional .geyser.CommitmentLevel commitment = 2;
  bool has_commitment() const;
  void clear_commitment() ;
  ::geyser::CommitmentLevel commitment() const;
  void set_commitment(::geyser::CommitmentLevel value);

  private:
  ::geyser::CommitmentLevel _internal_commitment() const;
  void _internal_set_commitment(::geyser::CommitmentLevel value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.IsBlockhashValidRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IsBlockhashValidRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr blockhash_;
    int commitment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IsBlockhashValidRequest_class_data_;
// -------------------------------------------------------------------

class GetVersionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetVersionResponse) */ {
 public:
  inline GetVersionResponse() : GetVersionResponse(nullptr) {}
  ~GetVersionResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetVersionResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetVersionResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetVersionResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetVersionResponse(const GetVersionResponse& from) : GetVersionResponse(nullptr, from) {}
  inline GetVersionResponse(GetVersionResponse&& from) noexcept
      : GetVersionResponse(nullptr, ::std::move(from)) {}
  inline GetVersionResponse& operator=(const GetVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionResponse& operator=(GetVersionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionResponse& default_instance() {
    return *reinterpret_cast<const GetVersionResponse*>(
        &_GetVersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(GetVersionResponse& a, GetVersionResponse& b) { a.Swap(&b); }
  inline void Swap(GetVersionResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVersionResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetVersionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetVersionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetVersionResponse& from) { GetVersionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetVersionResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetVersionResponse"; }

 protected:
  explicit GetVersionResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetVersionResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetVersionResponse& from);
  GetVersionResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetVersionResponse&& from) noexcept
      : GetVersionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version() ;
  const ::std::string& version() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_version();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_version();
  void set_allocated_version(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_version(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetVersionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetVersionResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetVersionResponse_class_data_;
// -------------------------------------------------------------------

class GetVersionRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:geyser.GetVersionRequest) */ {
 public:
  inline GetVersionRequest() : GetVersionRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetVersionRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetVersionRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetVersionRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetVersionRequest(const GetVersionRequest& from) : GetVersionRequest(nullptr, from) {}
  inline GetVersionRequest(GetVersionRequest&& from) noexcept
      : GetVersionRequest(nullptr, ::std::move(from)) {}
  inline GetVersionRequest& operator=(const GetVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionRequest& operator=(GetVersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionRequest& default_instance() {
    return *reinterpret_cast<const GetVersionRequest*>(
        &_GetVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(GetVersionRequest& a, GetVersionRequest& b) { a.Swap(&b); }
  inline void Swap(GetVersionRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVersionRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetVersionRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetVersionRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetVersionRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetVersionRequest"; }

 protected:
  explicit GetVersionRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetVersionRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetVersionRequest& from);
  GetVersionRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetVersionRequest&& from) noexcept
      : GetVersionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:geyser.GetVersionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetVersionRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetVersionRequest_class_data_;
// -------------------------------------------------------------------

class GetSlotResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetSlotResponse) */ {
 public:
  inline GetSlotResponse() : GetSlotResponse(nullptr) {}
  ~GetSlotResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetSlotResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetSlotResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSlotResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetSlotResponse(const GetSlotResponse& from) : GetSlotResponse(nullptr, from) {}
  inline GetSlotResponse(GetSlotResponse&& from) noexcept
      : GetSlotResponse(nullptr, ::std::move(from)) {}
  inline GetSlotResponse& operator=(const GetSlotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSlotResponse& operator=(GetSlotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSlotResponse& default_instance() {
    return *reinterpret_cast<const GetSlotResponse*>(
        &_GetSlotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(GetSlotResponse& a, GetSlotResponse& b) { a.Swap(&b); }
  inline void Swap(GetSlotResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSlotResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSlotResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetSlotResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSlotResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSlotResponse& from) { GetSlotResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetSlotResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetSlotResponse"; }

 protected:
  explicit GetSlotResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetSlotResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetSlotResponse& from);
  GetSlotResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetSlotResponse&& from) noexcept
      : GetSlotResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSlotFieldNumber = 1,
  };
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetSlotResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetSlotResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetSlotResponse_class_data_;
// -------------------------------------------------------------------

class GetSlotRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetSlotRequest) */ {
 public:
  inline GetSlotRequest() : GetSlotRequest(nullptr) {}
  ~GetSlotRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetSlotRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetSlotRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSlotRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetSlotRequest(const GetSlotRequest& from) : GetSlotRequest(nullptr, from) {}
  inline GetSlotRequest(GetSlotRequest&& from) noexcept
      : GetSlotRequest(nullptr, ::std::move(from)) {}
  inline GetSlotRequest& operator=(const GetSlotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSlotRequest& operator=(GetSlotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSlotRequest& default_instance() {
    return *reinterpret_cast<const GetSlotRequest*>(
        &_GetSlotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(GetSlotRequest& a, GetSlotRequest& b) { a.Swap(&b); }
  inline void Swap(GetSlotRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSlotRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSlotRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetSlotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSlotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSlotRequest& from) { GetSlotRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetSlotRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetSlotRequest"; }

 protected:
  explicit GetSlotRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetSlotRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetSlotRequest& from);
  GetSlotRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetSlotRequest&& from) noexcept
      : GetSlotRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommitmentFieldNumber = 1,
  };
  // optional .geyser.CommitmentLevel commitment = 1;
  bool has_commitment() const;
  void clear_commitment() ;
  ::geyser::CommitmentLevel commitment() const;
  void set_commitment(::geyser::CommitmentLevel value);

  private:
  ::geyser::CommitmentLevel _internal_commitment() const;
  void _internal_set_commitment(::geyser::CommitmentLevel value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetSlotRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetSlotRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int commitment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetSlotRequest_class_data_;
// -------------------------------------------------------------------

class GetLatestBlockhashResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetLatestBlockhashResponse) */ {
 public:
  inline GetLatestBlockhashResponse() : GetLatestBlockhashResponse(nullptr) {}
  ~GetLatestBlockhashResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetLatestBlockhashResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetLatestBlockhashResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetLatestBlockhashResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetLatestBlockhashResponse(const GetLatestBlockhashResponse& from) : GetLatestBlockhashResponse(nullptr, from) {}
  inline GetLatestBlockhashResponse(GetLatestBlockhashResponse&& from) noexcept
      : GetLatestBlockhashResponse(nullptr, ::std::move(from)) {}
  inline GetLatestBlockhashResponse& operator=(const GetLatestBlockhashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockhashResponse& operator=(GetLatestBlockhashResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockhashResponse& default_instance() {
    return *reinterpret_cast<const GetLatestBlockhashResponse*>(
        &_GetLatestBlockhashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(GetLatestBlockhashResponse& a, GetLatestBlockhashResponse& b) { a.Swap(&b); }
  inline void Swap(GetLatestBlockhashResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockhashResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestBlockhashResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetLatestBlockhashResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockhashResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockhashResponse& from) { GetLatestBlockhashResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetLatestBlockhashResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetLatestBlockhashResponse"; }

 protected:
  explicit GetLatestBlockhashResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetLatestBlockhashResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetLatestBlockhashResponse& from);
  GetLatestBlockhashResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetLatestBlockhashResponse&& from) noexcept
      : GetLatestBlockhashResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockhashFieldNumber = 2,
    kSlotFieldNumber = 1,
    kLastValidBlockHeightFieldNumber = 3,
  };
  // string blockhash = 2;
  void clear_blockhash() ;
  const ::std::string& blockhash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_blockhash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_blockhash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_blockhash();
  void set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_blockhash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_blockhash();

  public:
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // uint64 last_valid_block_height = 3;
  void clear_last_valid_block_height() ;
  ::uint64_t last_valid_block_height() const;
  void set_last_valid_block_height(::uint64_t value);

  private:
  ::uint64_t _internal_last_valid_block_height() const;
  void _internal_set_last_valid_block_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetLatestBlockhashResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetLatestBlockhashResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr blockhash_;
    ::uint64_t slot_;
    ::uint64_t last_valid_block_height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetLatestBlockhashResponse_class_data_;
// -------------------------------------------------------------------

class GetLatestBlockhashRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetLatestBlockhashRequest) */ {
 public:
  inline GetLatestBlockhashRequest() : GetLatestBlockhashRequest(nullptr) {}
  ~GetLatestBlockhashRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetLatestBlockhashRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetLatestBlockhashRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetLatestBlockhashRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetLatestBlockhashRequest(const GetLatestBlockhashRequest& from) : GetLatestBlockhashRequest(nullptr, from) {}
  inline GetLatestBlockhashRequest(GetLatestBlockhashRequest&& from) noexcept
      : GetLatestBlockhashRequest(nullptr, ::std::move(from)) {}
  inline GetLatestBlockhashRequest& operator=(const GetLatestBlockhashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockhashRequest& operator=(GetLatestBlockhashRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockhashRequest& default_instance() {
    return *reinterpret_cast<const GetLatestBlockhashRequest*>(
        &_GetLatestBlockhashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(GetLatestBlockhashRequest& a, GetLatestBlockhashRequest& b) { a.Swap(&b); }
  inline void Swap(GetLatestBlockhashRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockhashRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestBlockhashRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetLatestBlockhashRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockhashRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockhashRequest& from) { GetLatestBlockhashRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetLatestBlockhashRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetLatestBlockhashRequest"; }

 protected:
  explicit GetLatestBlockhashRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetLatestBlockhashRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetLatestBlockhashRequest& from);
  GetLatestBlockhashRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetLatestBlockhashRequest&& from) noexcept
      : GetLatestBlockhashRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommitmentFieldNumber = 1,
  };
  // optional .geyser.CommitmentLevel commitment = 1;
  bool has_commitment() const;
  void clear_commitment() ;
  ::geyser::CommitmentLevel commitment() const;
  void set_commitment(::geyser::CommitmentLevel value);

  private:
  ::geyser::CommitmentLevel _internal_commitment() const;
  void _internal_set_commitment(::geyser::CommitmentLevel value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetLatestBlockhashRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetLatestBlockhashRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int commitment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetLatestBlockhashRequest_class_data_;
// -------------------------------------------------------------------

class GetBlockHeightResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetBlockHeightResponse) */ {
 public:
  inline GetBlockHeightResponse() : GetBlockHeightResponse(nullptr) {}
  ~GetBlockHeightResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBlockHeightResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBlockHeightResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlockHeightResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetBlockHeightResponse(const GetBlockHeightResponse& from) : GetBlockHeightResponse(nullptr, from) {}
  inline GetBlockHeightResponse(GetBlockHeightResponse&& from) noexcept
      : GetBlockHeightResponse(nullptr, ::std::move(from)) {}
  inline GetBlockHeightResponse& operator=(const GetBlockHeightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeightResponse& operator=(GetBlockHeightResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeightResponse& default_instance() {
    return *reinterpret_cast<const GetBlockHeightResponse*>(
        &_GetBlockHeightResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(GetBlockHeightResponse& a, GetBlockHeightResponse& b) { a.Swap(&b); }
  inline void Swap(GetBlockHeightResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeightResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockHeightResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetBlockHeightResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBlockHeightResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBlockHeightResponse& from) { GetBlockHeightResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetBlockHeightResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetBlockHeightResponse"; }

 protected:
  explicit GetBlockHeightResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetBlockHeightResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetBlockHeightResponse& from);
  GetBlockHeightResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetBlockHeightResponse&& from) noexcept
      : GetBlockHeightResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockHeightFieldNumber = 1,
  };
  // uint64 block_height = 1;
  void clear_block_height() ;
  ::uint64_t block_height() const;
  void set_block_height(::uint64_t value);

  private:
  ::uint64_t _internal_block_height() const;
  void _internal_set_block_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetBlockHeightResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetBlockHeightResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t block_height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetBlockHeightResponse_class_data_;
// -------------------------------------------------------------------

class GetBlockHeightRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.GetBlockHeightRequest) */ {
 public:
  inline GetBlockHeightRequest() : GetBlockHeightRequest(nullptr) {}
  ~GetBlockHeightRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBlockHeightRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBlockHeightRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlockHeightRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetBlockHeightRequest(const GetBlockHeightRequest& from) : GetBlockHeightRequest(nullptr, from) {}
  inline GetBlockHeightRequest(GetBlockHeightRequest&& from) noexcept
      : GetBlockHeightRequest(nullptr, ::std::move(from)) {}
  inline GetBlockHeightRequest& operator=(const GetBlockHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeightRequest& operator=(GetBlockHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeightRequest& default_instance() {
    return *reinterpret_cast<const GetBlockHeightRequest*>(
        &_GetBlockHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(GetBlockHeightRequest& a, GetBlockHeightRequest& b) { a.Swap(&b); }
  inline void Swap(GetBlockHeightRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeightRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockHeightRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetBlockHeightRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBlockHeightRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBlockHeightRequest& from) { GetBlockHeightRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetBlockHeightRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.GetBlockHeightRequest"; }

 protected:
  explicit GetBlockHeightRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetBlockHeightRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetBlockHeightRequest& from);
  GetBlockHeightRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetBlockHeightRequest&& from) noexcept
      : GetBlockHeightRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommitmentFieldNumber = 1,
  };
  // optional .geyser.CommitmentLevel commitment = 1;
  bool has_commitment() const;
  void clear_commitment() ;
  ::geyser::CommitmentLevel commitment() const;
  void set_commitment(::geyser::CommitmentLevel value);

  private:
  ::geyser::CommitmentLevel _internal_commitment() const;
  void _internal_set_commitment(::geyser::CommitmentLevel value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.GetBlockHeightRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetBlockHeightRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int commitment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetBlockHeightRequest_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateTransactionStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateTransactionStatus) */ {
 public:
  inline SubscribeUpdateTransactionStatus() : SubscribeUpdateTransactionStatus(nullptr) {}
  ~SubscribeUpdateTransactionStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateTransactionStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateTransactionStatus(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateTransactionStatus(const SubscribeUpdateTransactionStatus& from) : SubscribeUpdateTransactionStatus(nullptr, from) {}
  inline SubscribeUpdateTransactionStatus(SubscribeUpdateTransactionStatus&& from) noexcept
      : SubscribeUpdateTransactionStatus(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateTransactionStatus& operator=(const SubscribeUpdateTransactionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateTransactionStatus& operator=(SubscribeUpdateTransactionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateTransactionStatus& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateTransactionStatus*>(
        &_SubscribeUpdateTransactionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(SubscribeUpdateTransactionStatus& a, SubscribeUpdateTransactionStatus& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateTransactionStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateTransactionStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateTransactionStatus& from) { SubscribeUpdateTransactionStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateTransactionStatus"; }

 protected:
  explicit SubscribeUpdateTransactionStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateTransactionStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateTransactionStatus& from);
  SubscribeUpdateTransactionStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateTransactionStatus&& from) noexcept
      : SubscribeUpdateTransactionStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSignatureFieldNumber = 2,
    kErrFieldNumber = 5,
    kSlotFieldNumber = 1,
    kIndexFieldNumber = 4,
    kIsVoteFieldNumber = 3,
  };
  // bytes signature = 2;
  void clear_signature() ;
  const ::std::string& signature() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_signature();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_signature();
  void set_allocated_signature(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_signature() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_signature();

  public:
  // .solana.storage.ConfirmedBlock.TransactionError err = 5;
  bool has_err() const;
  void clear_err() ;
  const ::solana::storage::ConfirmedBlock::TransactionError& err() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE release_err();
  ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NONNULL mutable_err();
  void set_allocated_err(::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_err(::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE unsafe_arena_release_err();

  private:
  const ::solana::storage::ConfirmedBlock::TransactionError& _internal_err() const;
  ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NONNULL _internal_mutable_err();

  public:
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // uint64 index = 4;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // bool is_vote = 3;
  void clear_is_vote() ;
  bool is_vote() const;
  void set_is_vote(bool value);

  private:
  bool _internal_is_vote() const;
  void _internal_set_is_vote(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateTransactionStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateTransactionStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE err_;
    ::uint64_t slot_;
    ::uint64_t index_;
    bool is_vote_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateTransactionStatus_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateAccount final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateAccount) */ {
 public:
  inline SubscribeUpdateAccount() : SubscribeUpdateAccount(nullptr) {}
  ~SubscribeUpdateAccount() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateAccount* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateAccount));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateAccount(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateAccount(const SubscribeUpdateAccount& from) : SubscribeUpdateAccount(nullptr, from) {}
  inline SubscribeUpdateAccount(SubscribeUpdateAccount&& from) noexcept
      : SubscribeUpdateAccount(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateAccount& operator=(const SubscribeUpdateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateAccount& operator=(SubscribeUpdateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateAccount& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateAccount*>(
        &_SubscribeUpdateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(SubscribeUpdateAccount& a, SubscribeUpdateAccount& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateAccount* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateAccount* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateAccount* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateAccount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateAccount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateAccount& from) { SubscribeUpdateAccount::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateAccount* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateAccount"; }

 protected:
  explicit SubscribeUpdateAccount(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateAccount(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateAccount& from);
  SubscribeUpdateAccount(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateAccount&& from) noexcept
      : SubscribeUpdateAccount(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 1,
    kSlotFieldNumber = 2,
    kIsStartupFieldNumber = 3,
  };
  // .geyser.SubscribeUpdateAccountInfo account = 1;
  bool has_account() const;
  void clear_account() ;
  const ::geyser::SubscribeUpdateAccountInfo& account() const;
  [[nodiscard]] ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE release_account();
  ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL mutable_account();
  void set_allocated_account(::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account(::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE unsafe_arena_release_account();

  private:
  const ::geyser::SubscribeUpdateAccountInfo& _internal_account() const;
  ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL _internal_mutable_account();

  public:
  // uint64 slot = 2;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // bool is_startup = 3;
  void clear_is_startup() ;
  bool is_startup() const;
  void set_is_startup(bool value);

  private:
  bool _internal_is_startup() const;
  void _internal_set_is_startup(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateAccount)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateAccount& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE account_;
    ::uint64_t slot_;
    bool is_startup_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateAccount_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterAccountsFilter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterAccountsFilter) */ {
 public:
  inline SubscribeRequestFilterAccountsFilter() : SubscribeRequestFilterAccountsFilter(nullptr) {}
  ~SubscribeRequestFilterAccountsFilter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterAccountsFilter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterAccountsFilter(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterAccountsFilter(const SubscribeRequestFilterAccountsFilter& from) : SubscribeRequestFilterAccountsFilter(nullptr, from) {}
  inline SubscribeRequestFilterAccountsFilter(SubscribeRequestFilterAccountsFilter&& from) noexcept
      : SubscribeRequestFilterAccountsFilter(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterAccountsFilter& operator=(const SubscribeRequestFilterAccountsFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterAccountsFilter& operator=(SubscribeRequestFilterAccountsFilter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterAccountsFilter& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterAccountsFilter*>(
        &_SubscribeRequestFilterAccountsFilter_default_instance_);
  }
  enum FilterCase {
    kMemcmp = 1,
    kDatasize = 2,
    kTokenAccountState = 3,
    kLamports = 4,
    FILTER_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SubscribeRequestFilterAccountsFilter& a, SubscribeRequestFilterAccountsFilter& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterAccountsFilter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterAccountsFilter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterAccountsFilter& from) { SubscribeRequestFilterAccountsFilter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterAccountsFilter"; }

 protected:
  explicit SubscribeRequestFilterAccountsFilter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterAccountsFilter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterAccountsFilter& from);
  SubscribeRequestFilterAccountsFilter(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterAccountsFilter&& from) noexcept
      : SubscribeRequestFilterAccountsFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMemcmpFieldNumber = 1,
    kDatasizeFieldNumber = 2,
    kTokenAccountStateFieldNumber = 3,
    kLamportsFieldNumber = 4,
  };
  // .geyser.SubscribeRequestFilterAccountsFilterMemcmp memcmp = 1;
  bool has_memcmp() const;
  private:
  bool _internal_has_memcmp() const;

  public:
  void clear_memcmp() ;
  const ::geyser::SubscribeRequestFilterAccountsFilterMemcmp& memcmp() const;
  [[nodiscard]] ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE release_memcmp();
  ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL mutable_memcmp();
  void set_allocated_memcmp(::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_memcmp(::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE unsafe_arena_release_memcmp();

  private:
  const ::geyser::SubscribeRequestFilterAccountsFilterMemcmp& _internal_memcmp() const;
  ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL _internal_mutable_memcmp();

  public:
  // uint64 datasize = 2;
  bool has_datasize() const;
  void clear_datasize() ;
  ::uint64_t datasize() const;
  void set_datasize(::uint64_t value);

  private:
  ::uint64_t _internal_datasize() const;
  void _internal_set_datasize(::uint64_t value);

  public:
  // bool token_account_state = 3;
  bool has_token_account_state() const;
  void clear_token_account_state() ;
  bool token_account_state() const;
  void set_token_account_state(bool value);

  private:
  bool _internal_token_account_state() const;
  void _internal_set_token_account_state(bool value);

  public:
  // .geyser.SubscribeRequestFilterAccountsFilterLamports lamports = 4;
  bool has_lamports() const;
  private:
  bool _internal_has_lamports() const;

  public:
  void clear_lamports() ;
  const ::geyser::SubscribeRequestFilterAccountsFilterLamports& lamports() const;
  [[nodiscard]] ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE release_lamports();
  ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL mutable_lamports();
  void set_allocated_lamports(::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lamports(::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE unsafe_arena_release_lamports();

  private:
  const ::geyser::SubscribeRequestFilterAccountsFilterLamports& _internal_lamports() const;
  ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL _internal_mutable_lamports();

  public:
  void clear_filter();
  FilterCase filter_case() const;
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterAccountsFilter)
 private:
  class _Internal;
  void set_has_memcmp();
  void set_has_datasize();
  void set_has_token_account_state();
  void set_has_lamports();
  inline bool has_filter() const;
  inline void clear_has_filter();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterAccountsFilter& from_msg);
    union FilterUnion {
      constexpr FilterUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE memcmp_;
      ::uint64_t datasize_;
      bool token_account_state_;
      ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE lamports_;
    } filter_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccountsFilter_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_TransactionsStatusEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_TransactionsStatusEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_TransactionsStatusEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_TransactionsStatusEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_TransactionsStatusEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 59,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_TransactionsStatusEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_TransactionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_TransactionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_TransactionsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_TransactionsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_TransactionsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 53,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_TransactionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_SlotsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_SlotsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_SlotsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_SlotsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_SlotsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 46,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_SlotsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_EntryEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_EntryEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_EntryEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_EntryEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_EntryEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 46,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_EntryEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_BlocksMetaEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_BlocksMetaEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_BlocksMetaEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_BlocksMetaEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_BlocksMetaEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 51,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_BlocksMetaEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_BlocksEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_BlocksEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_BlocksEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_BlocksEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_BlocksEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 47,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_BlocksEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateBlockMeta final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateBlockMeta) */ {
 public:
  inline SubscribeUpdateBlockMeta() : SubscribeUpdateBlockMeta(nullptr) {}
  ~SubscribeUpdateBlockMeta() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateBlockMeta* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateBlockMeta));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateBlockMeta(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateBlockMeta(const SubscribeUpdateBlockMeta& from) : SubscribeUpdateBlockMeta(nullptr, from) {}
  inline SubscribeUpdateBlockMeta(SubscribeUpdateBlockMeta&& from) noexcept
      : SubscribeUpdateBlockMeta(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateBlockMeta& operator=(const SubscribeUpdateBlockMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateBlockMeta& operator=(SubscribeUpdateBlockMeta&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateBlockMeta& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateBlockMeta*>(
        &_SubscribeUpdateBlockMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(SubscribeUpdateBlockMeta& a, SubscribeUpdateBlockMeta& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateBlockMeta* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateBlockMeta* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateBlockMeta* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateBlockMeta>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateBlockMeta& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateBlockMeta& from) { SubscribeUpdateBlockMeta::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateBlockMeta* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateBlockMeta"; }

 protected:
  explicit SubscribeUpdateBlockMeta(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateBlockMeta(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateBlockMeta& from);
  SubscribeUpdateBlockMeta(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateBlockMeta&& from) noexcept
      : SubscribeUpdateBlockMeta(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockhashFieldNumber = 2,
    kParentBlockhashFieldNumber = 7,
    kRewardsFieldNumber = 3,
    kBlockTimeFieldNumber = 4,
    kBlockHeightFieldNumber = 5,
    kSlotFieldNumber = 1,
    kParentSlotFieldNumber = 6,
    kExecutedTransactionCountFieldNumber = 8,
    kEntriesCountFieldNumber = 9,
  };
  // string blockhash = 2;
  void clear_blockhash() ;
  const ::std::string& blockhash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_blockhash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_blockhash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_blockhash();
  void set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_blockhash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_blockhash();

  public:
  // string parent_blockhash = 7;
  void clear_parent_blockhash() ;
  const ::std::string& parent_blockhash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_parent_blockhash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_parent_blockhash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_parent_blockhash();
  void set_allocated_parent_blockhash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_parent_blockhash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_parent_blockhash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_parent_blockhash();

  public:
  // .solana.storage.ConfirmedBlock.Rewards rewards = 3;
  bool has_rewards() const;
  void clear_rewards() ;
  const ::solana::storage::ConfirmedBlock::Rewards& rewards() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE release_rewards();
  ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL mutable_rewards();
  void set_allocated_rewards(::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rewards(::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE unsafe_arena_release_rewards();

  private:
  const ::solana::storage::ConfirmedBlock::Rewards& _internal_rewards() const;
  ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL _internal_mutable_rewards();

  public:
  // .solana.storage.ConfirmedBlock.UnixTimestamp block_time = 4;
  bool has_block_time() const;
  void clear_block_time() ;
  const ::solana::storage::ConfirmedBlock::UnixTimestamp& block_time() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE release_block_time();
  ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL mutable_block_time();
  void set_allocated_block_time(::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_time(::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE unsafe_arena_release_block_time();

  private:
  const ::solana::storage::ConfirmedBlock::UnixTimestamp& _internal_block_time() const;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL _internal_mutable_block_time();

  public:
  // .solana.storage.ConfirmedBlock.BlockHeight block_height = 5;
  bool has_block_height() const;
  void clear_block_height() ;
  const ::solana::storage::ConfirmedBlock::BlockHeight& block_height() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE release_block_height();
  ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL mutable_block_height();
  void set_allocated_block_height(::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_height(::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE unsafe_arena_release_block_height();

  private:
  const ::solana::storage::ConfirmedBlock::BlockHeight& _internal_block_height() const;
  ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL _internal_mutable_block_height();

  public:
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // uint64 parent_slot = 6;
  void clear_parent_slot() ;
  ::uint64_t parent_slot() const;
  void set_parent_slot(::uint64_t value);

  private:
  ::uint64_t _internal_parent_slot() const;
  void _internal_set_parent_slot(::uint64_t value);

  public:
  // uint64 executed_transaction_count = 8;
  void clear_executed_transaction_count() ;
  ::uint64_t executed_transaction_count() const;
  void set_executed_transaction_count(::uint64_t value);

  private:
  ::uint64_t _internal_executed_transaction_count() const;
  void _internal_set_executed_transaction_count(::uint64_t value);

  public:
  // uint64 entries_count = 9;
  void clear_entries_count() ;
  ::uint64_t entries_count() const;
  void set_entries_count(::uint64_t value);

  private:
  ::uint64_t _internal_entries_count() const;
  void _internal_set_entries_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateBlockMeta)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   3, 73,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateBlockMeta& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr blockhash_;
    ::google::protobuf::internal::ArenaStringPtr parent_blockhash_;
    ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE rewards_;
    ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE block_time_;
    ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE block_height_;
    ::uint64_t slot_;
    ::uint64_t parent_slot_;
    ::uint64_t executed_transaction_count_;
    ::uint64_t entries_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateBlockMeta_class_data_;
// -------------------------------------------------------------------

class SubscribeRequestFilterAccounts final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequestFilterAccounts) */ {
 public:
  inline SubscribeRequestFilterAccounts() : SubscribeRequestFilterAccounts(nullptr) {}
  ~SubscribeRequestFilterAccounts() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequestFilterAccounts* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequestFilterAccounts));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequestFilterAccounts(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequestFilterAccounts(const SubscribeRequestFilterAccounts& from) : SubscribeRequestFilterAccounts(nullptr, from) {}
  inline SubscribeRequestFilterAccounts(SubscribeRequestFilterAccounts&& from) noexcept
      : SubscribeRequestFilterAccounts(nullptr, ::std::move(from)) {}
  inline SubscribeRequestFilterAccounts& operator=(const SubscribeRequestFilterAccounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequestFilterAccounts& operator=(SubscribeRequestFilterAccounts&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequestFilterAccounts& default_instance() {
    return *reinterpret_cast<const SubscribeRequestFilterAccounts*>(
        &_SubscribeRequestFilterAccounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SubscribeRequestFilterAccounts& a, SubscribeRequestFilterAccounts& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequestFilterAccounts* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequestFilterAccounts* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequestFilterAccounts* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequestFilterAccounts>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequestFilterAccounts& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequestFilterAccounts& from) { SubscribeRequestFilterAccounts::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequestFilterAccounts* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequestFilterAccounts"; }

 protected:
  explicit SubscribeRequestFilterAccounts(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequestFilterAccounts(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequestFilterAccounts& from);
  SubscribeRequestFilterAccounts(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequestFilterAccounts&& from) noexcept
      : SubscribeRequestFilterAccounts(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kFiltersFieldNumber = 4,
    kNonemptyTxnSignatureFieldNumber = 5,
  };
  // repeated string account = 2;
  int account_size() const;
  private:
  int _internal_account_size() const;

  public:
  void clear_account() ;
  const ::std::string& account(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_account(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_account();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_account(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& account() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_account();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_account() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_account();

  public:
  // repeated string owner = 3;
  int owner_size() const;
  private:
  int _internal_owner_size() const;

  public:
  void clear_owner() ;
  const ::std::string& owner(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_owner(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_owner(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_owner();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_owner(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& owner() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_owner();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_owner() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_owner();

  public:
  // repeated .geyser.SubscribeRequestFilterAccountsFilter filters = 4;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  ::geyser::SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL mutable_filters(int index);
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>* PROTOBUF_NONNULL mutable_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>* PROTOBUF_NONNULL _internal_mutable_filters();
  public:
  const ::geyser::SubscribeRequestFilterAccountsFilter& filters(int index) const;
  ::geyser::SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL add_filters();
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>& filters() const;
  // optional bool nonempty_txn_signature = 5;
  bool has_nonempty_txn_signature() const;
  void clear_nonempty_txn_signature() ;
  bool nonempty_txn_signature() const;
  void set_nonempty_txn_signature(bool value);

  private:
  bool _internal_nonempty_txn_signature() const;
  void _internal_set_nonempty_txn_signature(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequestFilterAccounts)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequestFilterAccounts& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> account_;
    ::google::protobuf::RepeatedPtrField<::std::string> owner_;
    ::google::protobuf::RepeatedPtrField< ::geyser::SubscribeRequestFilterAccountsFilter > filters_;
    bool nonempty_txn_signature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequestFilterAccounts_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateTransactionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateTransactionInfo) */ {
 public:
  inline SubscribeUpdateTransactionInfo() : SubscribeUpdateTransactionInfo(nullptr) {}
  ~SubscribeUpdateTransactionInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateTransactionInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateTransactionInfo(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateTransactionInfo(const SubscribeUpdateTransactionInfo& from) : SubscribeUpdateTransactionInfo(nullptr, from) {}
  inline SubscribeUpdateTransactionInfo(SubscribeUpdateTransactionInfo&& from) noexcept
      : SubscribeUpdateTransactionInfo(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateTransactionInfo& operator=(const SubscribeUpdateTransactionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateTransactionInfo& operator=(SubscribeUpdateTransactionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateTransactionInfo& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateTransactionInfo*>(
        &_SubscribeUpdateTransactionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(SubscribeUpdateTransactionInfo& a, SubscribeUpdateTransactionInfo& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateTransactionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateTransactionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateTransactionInfo& from) { SubscribeUpdateTransactionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateTransactionInfo"; }

 protected:
  explicit SubscribeUpdateTransactionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateTransactionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateTransactionInfo& from);
  SubscribeUpdateTransactionInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateTransactionInfo&& from) noexcept
      : SubscribeUpdateTransactionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSignatureFieldNumber = 1,
    kTransactionFieldNumber = 3,
    kMetaFieldNumber = 4,
    kIndexFieldNumber = 5,
    kIsVoteFieldNumber = 2,
  };
  // bytes signature = 1;
  void clear_signature() ;
  const ::std::string& signature() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_signature();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_signature();
  void set_allocated_signature(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_signature() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_signature();

  public:
  // .solana.storage.ConfirmedBlock.Transaction transaction = 3;
  bool has_transaction() const;
  void clear_transaction() ;
  const ::solana::storage::ConfirmedBlock::Transaction& transaction() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE release_transaction();
  ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NONNULL mutable_transaction();
  void set_allocated_transaction(::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_transaction(::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE unsafe_arena_release_transaction();

  private:
  const ::solana::storage::ConfirmedBlock::Transaction& _internal_transaction() const;
  ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NONNULL _internal_mutable_transaction();

  public:
  // .solana.storage.ConfirmedBlock.TransactionStatusMeta meta = 4;
  bool has_meta() const;
  void clear_meta() ;
  const ::solana::storage::ConfirmedBlock::TransactionStatusMeta& meta() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE release_meta();
  ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NONNULL mutable_meta();
  void set_allocated_meta(::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_meta(::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE unsafe_arena_release_meta();

  private:
  const ::solana::storage::ConfirmedBlock::TransactionStatusMeta& _internal_meta() const;
  ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NONNULL _internal_mutable_meta();

  public:
  // uint64 index = 5;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // bool is_vote = 2;
  void clear_is_vote() ;
  bool is_vote() const;
  void set_is_vote(bool value);

  private:
  bool _internal_is_vote() const;
  void _internal_set_is_vote(bool value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateTransactionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateTransactionInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE transaction_;
    ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE meta_;
    ::uint64_t index_;
    bool is_vote_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateTransactionInfo_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest_AccountsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SubscribeRequest_AccountsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest_AccountsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubscribeRequest_AccountsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubscribeRequest_AccountsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_geyser_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_AccountsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateTransaction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateTransaction) */ {
 public:
  inline SubscribeUpdateTransaction() : SubscribeUpdateTransaction(nullptr) {}
  ~SubscribeUpdateTransaction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateTransaction* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateTransaction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateTransaction(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateTransaction(const SubscribeUpdateTransaction& from) : SubscribeUpdateTransaction(nullptr, from) {}
  inline SubscribeUpdateTransaction(SubscribeUpdateTransaction&& from) noexcept
      : SubscribeUpdateTransaction(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateTransaction& operator=(const SubscribeUpdateTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateTransaction& operator=(SubscribeUpdateTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateTransaction& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateTransaction*>(
        &_SubscribeUpdateTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(SubscribeUpdateTransaction& a, SubscribeUpdateTransaction& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateTransaction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateTransaction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateTransaction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateTransaction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateTransaction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateTransaction& from) { SubscribeUpdateTransaction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateTransaction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateTransaction"; }

 protected:
  explicit SubscribeUpdateTransaction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateTransaction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateTransaction& from);
  SubscribeUpdateTransaction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateTransaction&& from) noexcept
      : SubscribeUpdateTransaction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionFieldNumber = 1,
    kSlotFieldNumber = 2,
  };
  // .geyser.SubscribeUpdateTransactionInfo transaction = 1;
  bool has_transaction() const;
  void clear_transaction() ;
  const ::geyser::SubscribeUpdateTransactionInfo& transaction() const;
  [[nodiscard]] ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE release_transaction();
  ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL mutable_transaction();
  void set_allocated_transaction(::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_transaction(::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE unsafe_arena_release_transaction();

  private:
  const ::geyser::SubscribeUpdateTransactionInfo& _internal_transaction() const;
  ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL _internal_mutable_transaction();

  public:
  // uint64 slot = 2;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateTransaction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateTransaction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE transaction_;
    ::uint64_t slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateTransaction_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdateBlock final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdateBlock) */ {
 public:
  inline SubscribeUpdateBlock() : SubscribeUpdateBlock(nullptr) {}
  ~SubscribeUpdateBlock() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdateBlock* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdateBlock));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdateBlock(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdateBlock(const SubscribeUpdateBlock& from) : SubscribeUpdateBlock(nullptr, from) {}
  inline SubscribeUpdateBlock(SubscribeUpdateBlock&& from) noexcept
      : SubscribeUpdateBlock(nullptr, ::std::move(from)) {}
  inline SubscribeUpdateBlock& operator=(const SubscribeUpdateBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdateBlock& operator=(SubscribeUpdateBlock&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdateBlock& default_instance() {
    return *reinterpret_cast<const SubscribeUpdateBlock*>(
        &_SubscribeUpdateBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(SubscribeUpdateBlock& a, SubscribeUpdateBlock& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdateBlock* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdateBlock* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdateBlock* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdateBlock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdateBlock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdateBlock& from) { SubscribeUpdateBlock::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdateBlock* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdateBlock"; }

 protected:
  explicit SubscribeUpdateBlock(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdateBlock(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdateBlock& from);
  SubscribeUpdateBlock(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdateBlock&& from) noexcept
      : SubscribeUpdateBlock(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionsFieldNumber = 6,
    kAccountsFieldNumber = 11,
    kEntriesFieldNumber = 13,
    kBlockhashFieldNumber = 2,
    kParentBlockhashFieldNumber = 8,
    kRewardsFieldNumber = 3,
    kBlockTimeFieldNumber = 4,
    kBlockHeightFieldNumber = 5,
    kSlotFieldNumber = 1,
    kParentSlotFieldNumber = 7,
    kExecutedTransactionCountFieldNumber = 9,
    kUpdatedAccountCountFieldNumber = 10,
    kEntriesCountFieldNumber = 12,
  };
  // repeated .geyser.SubscribeUpdateTransactionInfo transactions = 6;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;

  public:
  void clear_transactions() ;
  ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL mutable_transactions(int index);
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>* PROTOBUF_NONNULL mutable_transactions();

  private:
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>& _internal_transactions() const;
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>* PROTOBUF_NONNULL _internal_mutable_transactions();
  public:
  const ::geyser::SubscribeUpdateTransactionInfo& transactions(int index) const;
  ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL add_transactions();
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>& transactions() const;
  // repeated .geyser.SubscribeUpdateAccountInfo accounts = 11;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL mutable_accounts(int index);
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>* PROTOBUF_NONNULL mutable_accounts();

  private:
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>& _internal_accounts() const;
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>* PROTOBUF_NONNULL _internal_mutable_accounts();
  public:
  const ::geyser::SubscribeUpdateAccountInfo& accounts(int index) const;
  ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL add_accounts();
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>& accounts() const;
  // repeated .geyser.SubscribeUpdateEntry entries = 13;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>* PROTOBUF_NONNULL mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>* PROTOBUF_NONNULL _internal_mutable_entries();
  public:
  const ::geyser::SubscribeUpdateEntry& entries(int index) const;
  ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL add_entries();
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>& entries() const;
  // string blockhash = 2;
  void clear_blockhash() ;
  const ::std::string& blockhash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_blockhash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_blockhash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_blockhash();
  void set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_blockhash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_blockhash();

  public:
  // string parent_blockhash = 8;
  void clear_parent_blockhash() ;
  const ::std::string& parent_blockhash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_parent_blockhash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_parent_blockhash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_parent_blockhash();
  void set_allocated_parent_blockhash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_parent_blockhash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_parent_blockhash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_parent_blockhash();

  public:
  // .solana.storage.ConfirmedBlock.Rewards rewards = 3;
  bool has_rewards() const;
  void clear_rewards() ;
  const ::solana::storage::ConfirmedBlock::Rewards& rewards() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE release_rewards();
  ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL mutable_rewards();
  void set_allocated_rewards(::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rewards(::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE unsafe_arena_release_rewards();

  private:
  const ::solana::storage::ConfirmedBlock::Rewards& _internal_rewards() const;
  ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL _internal_mutable_rewards();

  public:
  // .solana.storage.ConfirmedBlock.UnixTimestamp block_time = 4;
  bool has_block_time() const;
  void clear_block_time() ;
  const ::solana::storage::ConfirmedBlock::UnixTimestamp& block_time() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE release_block_time();
  ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL mutable_block_time();
  void set_allocated_block_time(::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_time(::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE unsafe_arena_release_block_time();

  private:
  const ::solana::storage::ConfirmedBlock::UnixTimestamp& _internal_block_time() const;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL _internal_mutable_block_time();

  public:
  // .solana.storage.ConfirmedBlock.BlockHeight block_height = 5;
  bool has_block_height() const;
  void clear_block_height() ;
  const ::solana::storage::ConfirmedBlock::BlockHeight& block_height() const;
  [[nodiscard]] ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE release_block_height();
  ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL mutable_block_height();
  void set_allocated_block_height(::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_height(::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value);
  ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE unsafe_arena_release_block_height();

  private:
  const ::solana::storage::ConfirmedBlock::BlockHeight& _internal_block_height() const;
  ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL _internal_mutable_block_height();

  public:
  // uint64 slot = 1;
  void clear_slot() ;
  ::uint64_t slot() const;
  void set_slot(::uint64_t value);

  private:
  ::uint64_t _internal_slot() const;
  void _internal_set_slot(::uint64_t value);

  public:
  // uint64 parent_slot = 7;
  void clear_parent_slot() ;
  ::uint64_t parent_slot() const;
  void set_parent_slot(::uint64_t value);

  private:
  ::uint64_t _internal_parent_slot() const;
  void _internal_set_parent_slot(::uint64_t value);

  public:
  // uint64 executed_transaction_count = 9;
  void clear_executed_transaction_count() ;
  ::uint64_t executed_transaction_count() const;
  void set_executed_transaction_count(::uint64_t value);

  private:
  ::uint64_t _internal_executed_transaction_count() const;
  void _internal_set_executed_transaction_count(::uint64_t value);

  public:
  // uint64 updated_account_count = 10;
  void clear_updated_account_count() ;
  ::uint64_t updated_account_count() const;
  void set_updated_account_count(::uint64_t value);

  private:
  ::uint64_t _internal_updated_account_count() const;
  void _internal_set_updated_account_count(::uint64_t value);

  public:
  // uint64 entries_count = 12;
  void clear_entries_count() ;
  ::uint64_t entries_count() const;
  void set_entries_count(::uint64_t value);

  private:
  ::uint64_t _internal_entries_count() const;
  void _internal_set_entries_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdateBlock)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13,
                                   6, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdateBlock& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::geyser::SubscribeUpdateTransactionInfo > transactions_;
    ::google::protobuf::RepeatedPtrField< ::geyser::SubscribeUpdateAccountInfo > accounts_;
    ::google::protobuf::RepeatedPtrField< ::geyser::SubscribeUpdateEntry > entries_;
    ::google::protobuf::internal::ArenaStringPtr blockhash_;
    ::google::protobuf::internal::ArenaStringPtr parent_blockhash_;
    ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE rewards_;
    ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE block_time_;
    ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE block_height_;
    ::uint64_t slot_;
    ::uint64_t parent_slot_;
    ::uint64_t executed_transaction_count_;
    ::uint64_t updated_account_count_;
    ::uint64_t entries_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdateBlock_class_data_;
// -------------------------------------------------------------------

class SubscribeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeRequest(const SubscribeRequest& from) : SubscribeRequest(nullptr, from) {}
  inline SubscribeRequest(SubscribeRequest&& from) noexcept
      : SubscribeRequest(nullptr, ::std::move(from)) {}
  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *reinterpret_cast<const SubscribeRequest*>(
        &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SubscribeRequest& a, SubscribeRequest& b) { a.Swap(&b); }
  inline void Swap(SubscribeRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeRequest& from) { SubscribeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeRequest"; }

 protected:
  explicit SubscribeRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeRequest& from);
  SubscribeRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeRequest&& from) noexcept
      : SubscribeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountsFieldNumber = 1,
    kSlotsFieldNumber = 2,
    kTransactionsFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kBlocksMetaFieldNumber = 5,
    kAccountsDataSliceFieldNumber = 7,
    kEntryFieldNumber = 8,
    kTransactionsStatusFieldNumber = 10,
    kPingFieldNumber = 9,
    kFromSlotFieldNumber = 11,
    kCommitmentFieldNumber = 6,
  };
  // map<string, .geyser.SubscribeRequestFilterAccounts> accounts = 1;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>& accounts() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>* PROTOBUF_NONNULL mutable_accounts();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>& _internal_accounts() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>* PROTOBUF_NONNULL _internal_mutable_accounts();

  public:
  // map<string, .geyser.SubscribeRequestFilterSlots> slots = 2;
  int slots_size() const;
  private:
  int _internal_slots_size() const;

  public:
  void clear_slots() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>& slots() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>* PROTOBUF_NONNULL mutable_slots();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>& _internal_slots() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>* PROTOBUF_NONNULL _internal_mutable_slots();

  public:
  // map<string, .geyser.SubscribeRequestFilterTransactions> transactions = 3;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;

  public:
  void clear_transactions() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& transactions() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL mutable_transactions();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& _internal_transactions() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL _internal_mutable_transactions();

  public:
  // map<string, .geyser.SubscribeRequestFilterBlocks> blocks = 4;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;

  public:
  void clear_blocks() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>& blocks() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>* PROTOBUF_NONNULL mutable_blocks();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>& _internal_blocks() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>* PROTOBUF_NONNULL _internal_mutable_blocks();

  public:
  // map<string, .geyser.SubscribeRequestFilterBlocksMeta> blocks_meta = 5;
  int blocks_meta_size() const;
  private:
  int _internal_blocks_meta_size() const;

  public:
  void clear_blocks_meta() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>& blocks_meta() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>* PROTOBUF_NONNULL mutable_blocks_meta();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>& _internal_blocks_meta() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>* PROTOBUF_NONNULL _internal_mutable_blocks_meta();

  public:
  // repeated .geyser.SubscribeRequestAccountsDataSlice accounts_data_slice = 7;
  int accounts_data_slice_size() const;
  private:
  int _internal_accounts_data_slice_size() const;

  public:
  void clear_accounts_data_slice() ;
  ::geyser::SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL mutable_accounts_data_slice(int index);
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>* PROTOBUF_NONNULL mutable_accounts_data_slice();

  private:
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>& _internal_accounts_data_slice() const;
  ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>* PROTOBUF_NONNULL _internal_mutable_accounts_data_slice();
  public:
  const ::geyser::SubscribeRequestAccountsDataSlice& accounts_data_slice(int index) const;
  ::geyser::SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL add_accounts_data_slice();
  const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>& accounts_data_slice() const;
  // map<string, .geyser.SubscribeRequestFilterEntry> entry = 8;
  int entry_size() const;
  private:
  int _internal_entry_size() const;

  public:
  void clear_entry() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>& entry() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>* PROTOBUF_NONNULL mutable_entry();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>& _internal_entry() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>* PROTOBUF_NONNULL _internal_mutable_entry();

  public:
  // map<string, .geyser.SubscribeRequestFilterTransactions> transactions_status = 10;
  int transactions_status_size() const;
  private:
  int _internal_transactions_status_size() const;

  public:
  void clear_transactions_status() ;
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& transactions_status() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL mutable_transactions_status();

  private:
  const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& _internal_transactions_status() const;
  ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL _internal_mutable_transactions_status();

  public:
  // optional .geyser.SubscribeRequestPing ping = 9;
  bool has_ping() const;
  void clear_ping() ;
  const ::geyser::SubscribeRequestPing& ping() const;
  [[nodiscard]] ::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE release_ping();
  ::geyser::SubscribeRequestPing* PROTOBUF_NONNULL mutable_ping();
  void set_allocated_ping(::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ping(::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE unsafe_arena_release_ping();

  private:
  const ::geyser::SubscribeRequestPing& _internal_ping() const;
  ::geyser::SubscribeRequestPing* PROTOBUF_NONNULL _internal_mutable_ping();

  public:
  // optional uint64 from_slot = 11;
  bool has_from_slot() const;
  void clear_from_slot() ;
  ::uint64_t from_slot() const;
  void set_from_slot(::uint64_t value);

  private:
  ::uint64_t _internal_from_slot() const;
  void _internal_set_from_slot(::uint64_t value);

  public:
  // optional .geyser.CommitmentLevel commitment = 6;
  bool has_commitment() const;
  void clear_commitment() ;
  ::geyser::CommitmentLevel commitment() const;
  void set_commitment(::geyser::CommitmentLevel value);

  private:
  ::geyser::CommitmentLevel _internal_commitment() const;
  void _internal_set_commitment(::geyser::CommitmentLevel value);

  public:
  // @@protoc_insertion_point(class_scope:geyser.SubscribeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 11,
                                   16, 106,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<SubscribeRequest_AccountsEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterAccounts,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        accounts_;
    ::google::protobuf::internal::MapField<SubscribeRequest_SlotsEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterSlots,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        slots_;
    ::google::protobuf::internal::MapField<SubscribeRequest_TransactionsEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterTransactions,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        transactions_;
    ::google::protobuf::internal::MapField<SubscribeRequest_BlocksEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterBlocks,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        blocks_;
    ::google::protobuf::internal::MapField<SubscribeRequest_BlocksMetaEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterBlocksMeta,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        blocks_meta_;
    ::google::protobuf::RepeatedPtrField< ::geyser::SubscribeRequestAccountsDataSlice > accounts_data_slice_;
    ::google::protobuf::internal::MapField<SubscribeRequest_EntryEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterEntry,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        entry_;
    ::google::protobuf::internal::MapField<SubscribeRequest_TransactionsStatusEntry_DoNotUse, std::string, ::geyser::SubscribeRequestFilterTransactions,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        transactions_status_;
    ::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE ping_;
    ::uint64_t from_slot_;
    int commitment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeRequest_class_data_;
// -------------------------------------------------------------------

class SubscribeUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:geyser.SubscribeUpdate) */ {
 public:
  inline SubscribeUpdate() : SubscribeUpdate(nullptr) {}
  ~SubscribeUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeUpdate(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeUpdate(const SubscribeUpdate& from) : SubscribeUpdate(nullptr, from) {}
  inline SubscribeUpdate(SubscribeUpdate&& from) noexcept
      : SubscribeUpdate(nullptr, ::std::move(from)) {}
  inline SubscribeUpdate& operator=(const SubscribeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeUpdate& operator=(SubscribeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeUpdate& default_instance() {
    return *reinterpret_cast<const SubscribeUpdate*>(
        &_SubscribeUpdate_default_instance_);
  }
  enum UpdateOneofCase {
    kAccount = 2,
    kSlot = 3,
    kTransaction = 4,
    kTransactionStatus = 10,
    kBlock = 5,
    kPing = 6,
    kPong = 9,
    kBlockMeta = 7,
    kEntry = 8,
    UPDATE_ONEOF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SubscribeUpdate& a, SubscribeUpdate& b) { a.Swap(&b); }
  inline void Swap(SubscribeUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeUpdate& from) { SubscribeUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "geyser.SubscribeUpdate"; }

 protected:
  explicit SubscribeUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeUpdate& from);
  SubscribeUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeUpdate&& from) noexcept
      : SubscribeUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFiltersFieldNumber = 1,
    kCreatedAtFieldNumber = 11,
    kAccountFieldNumber = 2,
    kSlotFieldNumber = 3,
    kTransactionFieldNumber = 4,
    kTransactionStatusFieldNumber = 10,
    kBlockFieldNumber = 5,
    kPingFieldNumber = 6,
    kPongFieldNumber = 9,
    kBlockMetaFieldNumber = 7,
    kEntryFieldNumber = 8,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  const ::std::string& filters(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_filters(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_filters(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_filters();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_filters(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& filters() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_filters();

  public:
  // .google.protobuf.Timestamp created_at = 11;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_created_at();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_created_at();

  public:
  // .geyser.SubscribeUpdateAccount account = 2;
  bool has_account() const;
  private:
  bool _internal_has_account() const;

  public:
  void clear_account() ;
  const ::geyser::SubscribeUpdateAccount& account() const;
  [[nodiscard]] ::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE release_account();
  ::geyser::SubscribeUpdateAccount* PROTOBUF_NONNULL mutable_account();
  void set_allocated_account(::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account(::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE unsafe_arena_release_account();

  private:
  const ::geyser::SubscribeUpdateAccount& _internal_account() const;
  ::geyser::SubscribeUpdateAccount* PROTOBUF_NONNULL _internal_mutable_account();

  public:
  // .geyser.SubscribeUpdateSlot slot = 3;
  bool has_slot() const;
  private:
  bool _internal_has_slot() const;

  public:
  void clear_slot() ;
  const ::geyser::SubscribeUpdateSlot& slot() const;
  [[nodiscard]] ::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE release_slot();
  ::geyser::SubscribeUpdateSlot* PROTOBUF_NONNULL mutable_slot();
  void set_allocated_slot(::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_slot(::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE unsafe_arena_release_slot();

  private:
  const ::geyser::SubscribeUpdateSlot& _internal_slot() const;
  ::geyser::SubscribeUpdateSlot* PROTOBUF_NONNULL _internal_mutable_slot();

  public:
  // .geyser.SubscribeUpdateTransaction transaction = 4;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;

  public:
  void clear_transaction() ;
  const ::geyser::SubscribeUpdateTransaction& transaction() const;
  [[nodiscard]] ::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE release_transaction();
  ::geyser::SubscribeUpdateTransaction* PROTOBUF_NONNULL mutable_transaction();
  void set_allocated_transaction(::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_transaction(::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE unsafe_arena_release_transaction();

  private:
  const ::geyser::SubscribeUpdateTransaction& _internal_transaction() const;
  ::geyser::SubscribeUpdateTransaction* PROTOBUF_NONNULL _internal_mutable_transaction();

  public:
  // .geyser.SubscribeUpdateTransactionStatus transaction_status = 10;
  bool has_transaction_status() const;
  private:
  bool _internal_has_transaction_status() const;

  public:
  void clear_transaction_status() ;
  const ::geyser::SubscribeUpdateTransactionStatus& transaction_status() const;
  [[nodiscard]] ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE release_transaction_status();
  ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL mutable_transaction_status();
  void set_allocated_transaction_status(::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_transaction_status(::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE unsafe_arena_release_transaction_status();

  private:
  const ::geyser::SubscribeUpdateTransactionStatus& _internal_transaction_status() const;
  ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL _internal_mutable_transaction_status();

  public:
  // .geyser.SubscribeUpdateBlock block = 5;
  bool has_block() const;
  private:
  bool _internal_has_block() const;

  public:
  void clear_block() ;
  const ::geyser::SubscribeUpdateBlock& block() const;
  [[nodiscard]] ::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE release_block();
  ::geyser::SubscribeUpdateBlock* PROTOBUF_NONNULL mutable_block();
  void set_allocated_block(::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block(::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE unsafe_arena_release_block();

  private:
  const ::geyser::SubscribeUpdateBlock& _internal_block() const;
  ::geyser::SubscribeUpdateBlock* PROTOBUF_NONNULL _internal_mutable_block();

  public:
  // .geyser.SubscribeUpdatePing ping = 6;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;

  public:
  void clear_ping() ;
  const ::geyser::SubscribeUpdatePing& ping() const;
  [[nodiscard]] ::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE release_ping();
  ::geyser::SubscribeUpdatePing* PROTOBUF_NONNULL mutable_ping();
  void set_allocated_ping(::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ping(::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE unsafe_arena_release_ping();

  private:
  const ::geyser::SubscribeUpdatePing& _internal_ping() const;
  ::geyser::SubscribeUpdatePing* PROTOBUF_NONNULL _internal_mutable_ping();

  public:
  // .geyser.SubscribeUpdatePong pong = 9;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;

  public:
  void clear_pong() ;
  const ::geyser::SubscribeUpdatePong& pong() const;
  [[nodiscard]] ::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE release_pong();
  ::geyser::SubscribeUpdatePong* PROTOBUF_NONNULL mutable_pong();
  void set_allocated_pong(::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pong(::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE unsafe_arena_release_pong();

  private:
  const ::geyser::SubscribeUpdatePong& _internal_pong() const;
  ::geyser::SubscribeUpdatePong* PROTOBUF_NONNULL _internal_mutable_pong();

  public:
  // .geyser.SubscribeUpdateBlockMeta block_meta = 7;
  bool has_block_meta() const;
  private:
  bool _internal_has_block_meta() const;

  public:
  void clear_block_meta() ;
  const ::geyser::SubscribeUpdateBlockMeta& block_meta() const;
  [[nodiscard]] ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE release_block_meta();
  ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NONNULL mutable_block_meta();
  void set_allocated_block_meta(::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_meta(::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE unsafe_arena_release_block_meta();

  private:
  const ::geyser::SubscribeUpdateBlockMeta& _internal_block_meta() const;
  ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NONNULL _internal_mutable_block_meta();

  public:
  // .geyser.SubscribeUpdateEntry entry = 8;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;

  public:
  void clear_entry() ;
  const ::geyser::SubscribeUpdateEntry& entry() const;
  [[nodiscard]] ::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE release_entry();
  ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL mutable_entry();
  void set_allocated_entry(::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_entry(::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE value);
  ::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE unsafe_arena_release_entry();

  private:
  const ::geyser::SubscribeUpdateEntry& _internal_entry() const;
  ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL _internal_mutable_entry();

  public:
  void clear_update_oneof();
  UpdateOneofCase update_oneof_case() const;
  // @@protoc_insertion_point(class_scope:geyser.SubscribeUpdate)
 private:
  class _Internal;
  void set_has_account();
  void set_has_slot();
  void set_has_transaction();
  void set_has_transaction_status();
  void set_has_block();
  void set_has_ping();
  void set_has_pong();
  void set_has_block_meta();
  void set_has_entry();
  inline bool has_update_oneof() const;
  inline void clear_has_update_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 11,
                                   10, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> filters_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE created_at_;
    union UpdateOneofUnion {
      constexpr UpdateOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE slot_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE transaction_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE transaction_status_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE block_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ping_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pong_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE block_meta_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE entry_;
    } update_oneof_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_geyser_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeUpdate_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SubscribeRequest

// map<string, .geyser.SubscribeRequestFilterAccounts> accounts = 1;
inline int SubscribeRequest::_internal_accounts_size() const {
  return _internal_accounts().size();
}
inline int SubscribeRequest::accounts_size() const {
  return _internal_accounts_size();
}
inline void SubscribeRequest::clear_accounts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accounts_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>& SubscribeRequest::_internal_accounts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.accounts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>& SubscribeRequest::accounts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.accounts)
  return _internal_accounts();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_accounts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.accounts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterAccounts>* PROTOBUF_NONNULL SubscribeRequest::mutable_accounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.accounts)
  return _internal_mutable_accounts();
}

// map<string, .geyser.SubscribeRequestFilterSlots> slots = 2;
inline int SubscribeRequest::_internal_slots_size() const {
  return _internal_slots().size();
}
inline int SubscribeRequest::slots_size() const {
  return _internal_slots_size();
}
inline void SubscribeRequest::clear_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slots_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>& SubscribeRequest::_internal_slots() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slots_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>& SubscribeRequest::slots() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.slots)
  return _internal_slots();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.slots_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterSlots>* PROTOBUF_NONNULL SubscribeRequest::mutable_slots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.slots)
  return _internal_mutable_slots();
}

// map<string, .geyser.SubscribeRequestFilterTransactions> transactions = 3;
inline int SubscribeRequest::_internal_transactions_size() const {
  return _internal_transactions().size();
}
inline int SubscribeRequest::transactions_size() const {
  return _internal_transactions_size();
}
inline void SubscribeRequest::clear_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transactions_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& SubscribeRequest::_internal_transactions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transactions_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& SubscribeRequest::transactions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.transactions)
  return _internal_transactions();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.transactions_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL SubscribeRequest::mutable_transactions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.transactions)
  return _internal_mutable_transactions();
}

// map<string, .geyser.SubscribeRequestFilterTransactions> transactions_status = 10;
inline int SubscribeRequest::_internal_transactions_status_size() const {
  return _internal_transactions_status().size();
}
inline int SubscribeRequest::transactions_status_size() const {
  return _internal_transactions_status_size();
}
inline void SubscribeRequest::clear_transactions_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transactions_status_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& SubscribeRequest::_internal_transactions_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transactions_status_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>& SubscribeRequest::transactions_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.transactions_status)
  return _internal_transactions_status();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_transactions_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.transactions_status_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterTransactions>* PROTOBUF_NONNULL SubscribeRequest::mutable_transactions_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.transactions_status)
  return _internal_mutable_transactions_status();
}

// map<string, .geyser.SubscribeRequestFilterBlocks> blocks = 4;
inline int SubscribeRequest::_internal_blocks_size() const {
  return _internal_blocks().size();
}
inline int SubscribeRequest::blocks_size() const {
  return _internal_blocks_size();
}
inline void SubscribeRequest::clear_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>& SubscribeRequest::_internal_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>& SubscribeRequest::blocks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.blocks)
  return _internal_blocks();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.blocks_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocks>* PROTOBUF_NONNULL SubscribeRequest::mutable_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.blocks)
  return _internal_mutable_blocks();
}

// map<string, .geyser.SubscribeRequestFilterBlocksMeta> blocks_meta = 5;
inline int SubscribeRequest::_internal_blocks_meta_size() const {
  return _internal_blocks_meta().size();
}
inline int SubscribeRequest::blocks_meta_size() const {
  return _internal_blocks_meta_size();
}
inline void SubscribeRequest::clear_blocks_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_meta_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>& SubscribeRequest::_internal_blocks_meta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_meta_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>& SubscribeRequest::blocks_meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.blocks_meta)
  return _internal_blocks_meta();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_blocks_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.blocks_meta_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterBlocksMeta>* PROTOBUF_NONNULL SubscribeRequest::mutable_blocks_meta()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.blocks_meta)
  return _internal_mutable_blocks_meta();
}

// map<string, .geyser.SubscribeRequestFilterEntry> entry = 8;
inline int SubscribeRequest::_internal_entry_size() const {
  return _internal_entry().size();
}
inline int SubscribeRequest::entry_size() const {
  return _internal_entry_size();
}
inline void SubscribeRequest::clear_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entry_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>& SubscribeRequest::_internal_entry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entry_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>& SubscribeRequest::entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:geyser.SubscribeRequest.entry)
  return _internal_entry();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entry_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::geyser::SubscribeRequestFilterEntry>* PROTOBUF_NONNULL SubscribeRequest::mutable_entry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:geyser.SubscribeRequest.entry)
  return _internal_mutable_entry();
}

// optional .geyser.CommitmentLevel commitment = 6;
inline bool SubscribeRequest::has_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SubscribeRequest::clear_commitment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::geyser::CommitmentLevel SubscribeRequest::commitment() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequest.commitment)
  return _internal_commitment();
}
inline void SubscribeRequest::set_commitment(::geyser::CommitmentLevel value) {
  _internal_set_commitment(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequest.commitment)
}
inline ::geyser::CommitmentLevel SubscribeRequest::_internal_commitment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::geyser::CommitmentLevel>(_impl_.commitment_);
}
inline void SubscribeRequest::_internal_set_commitment(::geyser::CommitmentLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = value;
}

// repeated .geyser.SubscribeRequestAccountsDataSlice accounts_data_slice = 7;
inline int SubscribeRequest::_internal_accounts_data_slice_size() const {
  return _internal_accounts_data_slice().size();
}
inline int SubscribeRequest::accounts_data_slice_size() const {
  return _internal_accounts_data_slice_size();
}
inline void SubscribeRequest::clear_accounts_data_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accounts_data_slice_.Clear();
}
inline ::geyser::SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL SubscribeRequest::mutable_accounts_data_slice(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequest.accounts_data_slice)
  return _internal_mutable_accounts_data_slice()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>* PROTOBUF_NONNULL SubscribeRequest::mutable_accounts_data_slice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequest.accounts_data_slice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_accounts_data_slice();
}
inline const ::geyser::SubscribeRequestAccountsDataSlice& SubscribeRequest::accounts_data_slice(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequest.accounts_data_slice)
  return _internal_accounts_data_slice().Get(index);
}
inline ::geyser::SubscribeRequestAccountsDataSlice* PROTOBUF_NONNULL SubscribeRequest::add_accounts_data_slice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::geyser::SubscribeRequestAccountsDataSlice* _add = _internal_mutable_accounts_data_slice()->Add();
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequest.accounts_data_slice)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>& SubscribeRequest::accounts_data_slice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequest.accounts_data_slice)
  return _internal_accounts_data_slice();
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>&
SubscribeRequest::_internal_accounts_data_slice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.accounts_data_slice_;
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestAccountsDataSlice>* PROTOBUF_NONNULL
SubscribeRequest::_internal_mutable_accounts_data_slice() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.accounts_data_slice_;
}

// optional .geyser.SubscribeRequestPing ping = 9;
inline bool SubscribeRequest::has_ping() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ping_ != nullptr);
  return value;
}
inline void SubscribeRequest::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ping_ != nullptr) _impl_.ping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geyser::SubscribeRequestPing& SubscribeRequest::_internal_ping() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::geyser::SubscribeRequestPing* p = _impl_.ping_;
  return p != nullptr ? *p : reinterpret_cast<const ::geyser::SubscribeRequestPing&>(::geyser::_SubscribeRequestPing_default_instance_);
}
inline const ::geyser::SubscribeRequestPing& SubscribeRequest::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequest.ping)
  return _internal_ping();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_ping(
    ::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ping_);
  }
  _impl_.ping_ = reinterpret_cast<::geyser::SubscribeRequestPing*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeRequest.ping)
}
inline ::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE SubscribeRequest::release_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geyser::SubscribeRequestPing* released = _impl_.ping_;
  _impl_.ping_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE SubscribeRequest::unsafe_arena_release_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequest.ping)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geyser::SubscribeRequestPing* temp = _impl_.ping_;
  _impl_.ping_ = nullptr;
  return temp;
}
inline ::geyser::SubscribeRequestPing* PROTOBUF_NONNULL SubscribeRequest::_internal_mutable_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ping_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeRequestPing>(GetArena());
    _impl_.ping_ = reinterpret_cast<::geyser::SubscribeRequestPing*>(p);
  }
  return _impl_.ping_;
}
inline ::geyser::SubscribeRequestPing* PROTOBUF_NONNULL SubscribeRequest::mutable_ping()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::geyser::SubscribeRequestPing* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequest.ping)
  return _msg;
}
inline void SubscribeRequest::set_allocated_ping(::geyser::SubscribeRequestPing* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ping_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ping_ = reinterpret_cast<::geyser::SubscribeRequestPing*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeRequest.ping)
}

// optional uint64 from_slot = 11;
inline bool SubscribeRequest::has_from_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SubscribeRequest::clear_from_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SubscribeRequest::from_slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequest.from_slot)
  return _internal_from_slot();
}
inline void SubscribeRequest::set_from_slot(::uint64_t value) {
  _internal_set_from_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequest.from_slot)
}
inline ::uint64_t SubscribeRequest::_internal_from_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_slot_;
}
inline void SubscribeRequest::_internal_set_from_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_slot_ = value;
}

// -------------------------------------------------------------------

// SubscribeRequestFilterAccounts

// repeated string account = 2;
inline int SubscribeRequestFilterAccounts::_internal_account_size() const {
  return _internal_account().size();
}
inline int SubscribeRequestFilterAccounts::account_size() const {
  return _internal_account_size();
}
inline void SubscribeRequestFilterAccounts::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::add_account()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_account()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeRequestFilterAccounts.account)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterAccounts::account(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccounts.account)
  return _internal_account().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::mutable_account(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccounts.account)
  return _internal_mutable_account()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterAccounts::set_account(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_account()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccounts.account)
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterAccounts::add_account(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_account(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterAccounts.account)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeRequestFilterAccounts::account()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterAccounts.account)
  return _internal_account();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterAccounts::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterAccounts.account)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_account();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeRequestFilterAccounts::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterAccounts::_internal_mutable_account() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.account_;
}

// repeated string owner = 3;
inline int SubscribeRequestFilterAccounts::_internal_owner_size() const {
  return _internal_owner().size();
}
inline int SubscribeRequestFilterAccounts::owner_size() const {
  return _internal_owner_size();
}
inline void SubscribeRequestFilterAccounts::clear_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.owner_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::add_owner()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_owner()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeRequestFilterAccounts.owner)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterAccounts::owner(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccounts.owner)
  return _internal_owner().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::mutable_owner(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccounts.owner)
  return _internal_mutable_owner()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterAccounts::set_owner(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_owner()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccounts.owner)
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterAccounts::add_owner(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_owner(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterAccounts.owner)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeRequestFilterAccounts::owner()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterAccounts.owner)
  return _internal_owner();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterAccounts::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterAccounts.owner)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_owner();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeRequestFilterAccounts::_internal_owner() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.owner_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterAccounts::_internal_mutable_owner() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.owner_;
}

// repeated .geyser.SubscribeRequestFilterAccountsFilter filters = 4;
inline int SubscribeRequestFilterAccounts::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int SubscribeRequestFilterAccounts::filters_size() const {
  return _internal_filters_size();
}
inline void SubscribeRequestFilterAccounts::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filters_.Clear();
}
inline ::geyser::SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccounts.filters)
  return _internal_mutable_filters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::mutable_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterAccounts.filters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_filters();
}
inline const ::geyser::SubscribeRequestFilterAccountsFilter& SubscribeRequestFilterAccounts::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccounts.filters)
  return _internal_filters().Get(index);
}
inline ::geyser::SubscribeRequestFilterAccountsFilter* PROTOBUF_NONNULL SubscribeRequestFilterAccounts::add_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::geyser::SubscribeRequestFilterAccountsFilter* _add = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterAccounts.filters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>& SubscribeRequestFilterAccounts::filters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterAccounts.filters)
  return _internal_filters();
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>&
SubscribeRequestFilterAccounts::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeRequestFilterAccountsFilter>* PROTOBUF_NONNULL
SubscribeRequestFilterAccounts::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.filters_;
}

// optional bool nonempty_txn_signature = 5;
inline bool SubscribeRequestFilterAccounts::has_nonempty_txn_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SubscribeRequestFilterAccounts::clear_nonempty_txn_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonempty_txn_signature_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SubscribeRequestFilterAccounts::nonempty_txn_signature() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccounts.nonempty_txn_signature)
  return _internal_nonempty_txn_signature();
}
inline void SubscribeRequestFilterAccounts::set_nonempty_txn_signature(bool value) {
  _internal_set_nonempty_txn_signature(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccounts.nonempty_txn_signature)
}
inline bool SubscribeRequestFilterAccounts::_internal_nonempty_txn_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonempty_txn_signature_;
}
inline void SubscribeRequestFilterAccounts::_internal_set_nonempty_txn_signature(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonempty_txn_signature_ = value;
}

// -------------------------------------------------------------------

// SubscribeRequestFilterAccountsFilter

// .geyser.SubscribeRequestFilterAccountsFilterMemcmp memcmp = 1;
inline bool SubscribeRequestFilterAccountsFilter::has_memcmp() const {
  return filter_case() == kMemcmp;
}
inline bool SubscribeRequestFilterAccountsFilter::_internal_has_memcmp() const {
  return filter_case() == kMemcmp;
}
inline void SubscribeRequestFilterAccountsFilter::set_has_memcmp() {
  _impl_._oneof_case_[0] = kMemcmp;
}
inline void SubscribeRequestFilterAccountsFilter::clear_memcmp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (filter_case() == kMemcmp) {
    if (GetArena() == nullptr) {
      delete _impl_.filter_.memcmp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.filter_.memcmp_);
    }
    clear_has_filter();
  }
}
inline ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilter::release_memcmp() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequestFilterAccountsFilter.memcmp)
  if (filter_case() == kMemcmp) {
    clear_has_filter();
    auto* temp = _impl_.filter_.memcmp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.filter_.memcmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeRequestFilterAccountsFilterMemcmp& SubscribeRequestFilterAccountsFilter::_internal_memcmp() const {
  return filter_case() == kMemcmp ? *_impl_.filter_.memcmp_ : reinterpret_cast<::geyser::SubscribeRequestFilterAccountsFilterMemcmp&>(::geyser::_SubscribeRequestFilterAccountsFilterMemcmp_default_instance_);
}
inline const ::geyser::SubscribeRequestFilterAccountsFilterMemcmp& SubscribeRequestFilterAccountsFilter::memcmp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilter.memcmp)
  return _internal_memcmp();
}
inline ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilter::unsafe_arena_release_memcmp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeRequestFilterAccountsFilter.memcmp)
  if (filter_case() == kMemcmp) {
    clear_has_filter();
    auto* temp = _impl_.filter_.memcmp_;
    _impl_.filter_.memcmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeRequestFilterAccountsFilter::unsafe_arena_set_allocated_memcmp(
    ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_filter();
  if (value) {
    set_has_memcmp();
    _impl_.filter_.memcmp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeRequestFilterAccountsFilter.memcmp)
}
inline ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilter::_internal_mutable_memcmp() {
  if (filter_case() != kMemcmp) {
    clear_filter();
    set_has_memcmp();
    _impl_.filter_.memcmp_ = 
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeRequestFilterAccountsFilterMemcmp>(GetArena());
  }
  return _impl_.filter_.memcmp_;
}
inline ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilter::mutable_memcmp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeRequestFilterAccountsFilterMemcmp* _msg = _internal_mutable_memcmp();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccountsFilter.memcmp)
  return _msg;
}

// uint64 datasize = 2;
inline bool SubscribeRequestFilterAccountsFilter::has_datasize() const {
  return filter_case() == kDatasize;
}
inline void SubscribeRequestFilterAccountsFilter::set_has_datasize() {
  _impl_._oneof_case_[0] = kDatasize;
}
inline void SubscribeRequestFilterAccountsFilter::clear_datasize() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (filter_case() == kDatasize) {
    _impl_.filter_.datasize_ = ::uint64_t{0u};
    clear_has_filter();
  }
}
inline ::uint64_t SubscribeRequestFilterAccountsFilter::datasize() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilter.datasize)
  return _internal_datasize();
}
inline void SubscribeRequestFilterAccountsFilter::set_datasize(::uint64_t value) {
  if (filter_case() != kDatasize) {
    clear_filter();
    set_has_datasize();
  }
  _impl_.filter_.datasize_ = value;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilter.datasize)
}
inline ::uint64_t SubscribeRequestFilterAccountsFilter::_internal_datasize() const {
  if (filter_case() == kDatasize) {
    return _impl_.filter_.datasize_;
  }
  return ::uint64_t{0u};
}

// bool token_account_state = 3;
inline bool SubscribeRequestFilterAccountsFilter::has_token_account_state() const {
  return filter_case() == kTokenAccountState;
}
inline void SubscribeRequestFilterAccountsFilter::set_has_token_account_state() {
  _impl_._oneof_case_[0] = kTokenAccountState;
}
inline void SubscribeRequestFilterAccountsFilter::clear_token_account_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (filter_case() == kTokenAccountState) {
    _impl_.filter_.token_account_state_ = false;
    clear_has_filter();
  }
}
inline bool SubscribeRequestFilterAccountsFilter::token_account_state() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilter.token_account_state)
  return _internal_token_account_state();
}
inline void SubscribeRequestFilterAccountsFilter::set_token_account_state(bool value) {
  if (filter_case() != kTokenAccountState) {
    clear_filter();
    set_has_token_account_state();
  }
  _impl_.filter_.token_account_state_ = value;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilter.token_account_state)
}
inline bool SubscribeRequestFilterAccountsFilter::_internal_token_account_state() const {
  if (filter_case() == kTokenAccountState) {
    return _impl_.filter_.token_account_state_;
  }
  return false;
}

// .geyser.SubscribeRequestFilterAccountsFilterLamports lamports = 4;
inline bool SubscribeRequestFilterAccountsFilter::has_lamports() const {
  return filter_case() == kLamports;
}
inline bool SubscribeRequestFilterAccountsFilter::_internal_has_lamports() const {
  return filter_case() == kLamports;
}
inline void SubscribeRequestFilterAccountsFilter::set_has_lamports() {
  _impl_._oneof_case_[0] = kLamports;
}
inline void SubscribeRequestFilterAccountsFilter::clear_lamports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (filter_case() == kLamports) {
    if (GetArena() == nullptr) {
      delete _impl_.filter_.lamports_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.filter_.lamports_);
    }
    clear_has_filter();
  }
}
inline ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilter::release_lamports() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequestFilterAccountsFilter.lamports)
  if (filter_case() == kLamports) {
    clear_has_filter();
    auto* temp = _impl_.filter_.lamports_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.filter_.lamports_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeRequestFilterAccountsFilterLamports& SubscribeRequestFilterAccountsFilter::_internal_lamports() const {
  return filter_case() == kLamports ? *_impl_.filter_.lamports_ : reinterpret_cast<::geyser::SubscribeRequestFilterAccountsFilterLamports&>(::geyser::_SubscribeRequestFilterAccountsFilterLamports_default_instance_);
}
inline const ::geyser::SubscribeRequestFilterAccountsFilterLamports& SubscribeRequestFilterAccountsFilter::lamports() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilter.lamports)
  return _internal_lamports();
}
inline ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilter::unsafe_arena_release_lamports() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeRequestFilterAccountsFilter.lamports)
  if (filter_case() == kLamports) {
    clear_has_filter();
    auto* temp = _impl_.filter_.lamports_;
    _impl_.filter_.lamports_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeRequestFilterAccountsFilter::unsafe_arena_set_allocated_lamports(
    ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_filter();
  if (value) {
    set_has_lamports();
    _impl_.filter_.lamports_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeRequestFilterAccountsFilter.lamports)
}
inline ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilter::_internal_mutable_lamports() {
  if (filter_case() != kLamports) {
    clear_filter();
    set_has_lamports();
    _impl_.filter_.lamports_ = 
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeRequestFilterAccountsFilterLamports>(GetArena());
  }
  return _impl_.filter_.lamports_;
}
inline ::geyser::SubscribeRequestFilterAccountsFilterLamports* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilter::mutable_lamports()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeRequestFilterAccountsFilterLamports* _msg = _internal_mutable_lamports();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccountsFilter.lamports)
  return _msg;
}

inline bool SubscribeRequestFilterAccountsFilter::has_filter() const {
  return filter_case() != FILTER_NOT_SET;
}
inline void SubscribeRequestFilterAccountsFilter::clear_has_filter() {
  _impl_._oneof_case_[0] = FILTER_NOT_SET;
}
inline SubscribeRequestFilterAccountsFilter::FilterCase SubscribeRequestFilterAccountsFilter::filter_case() const {
  return SubscribeRequestFilterAccountsFilter::FilterCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SubscribeRequestFilterAccountsFilterMemcmp

// uint64 offset = 1;
inline void SubscribeRequestFilterAccountsFilterMemcmp::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterMemcmp::offset() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterMemcmp.offset)
  return _internal_offset();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterMemcmp.offset)
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterMemcmp::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::_internal_set_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// bytes bytes = 2;
inline bool SubscribeRequestFilterAccountsFilterMemcmp::has_bytes() const {
  return data_case() == kBytes;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_has_bytes() {
  _impl_._oneof_case_[0] = kBytes;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::clear_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() == kBytes) {
    _impl_.data_.bytes_.Destroy();
    clear_has_data();
  }
}
inline const ::std::string& SubscribeRequestFilterAccountsFilterMemcmp::bytes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterMemcmp.bytes)
  return _internal_bytes();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeRequestFilterAccountsFilterMemcmp::set_bytes(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBytes) {
    clear_data();

    set_has_bytes();
    _impl_.data_.bytes_.InitDefault();
  }
  _impl_.data_.bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterMemcmp.bytes)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilterMemcmp::mutable_bytes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_bytes();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccountsFilterMemcmp.bytes)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterAccountsFilterMemcmp::_internal_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (data_case() != kBytes) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.bytes_.Get();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::_internal_set_bytes(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBytes) {
    clear_data();

    set_has_bytes();
    _impl_.data_.bytes_.InitDefault();
  }
  _impl_.data_.bytes_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilterMemcmp::_internal_mutable_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBytes) {
    clear_data();

    set_has_bytes();
    _impl_.data_.bytes_.InitDefault();
  }
  return _impl_.data_.bytes_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilterMemcmp::release_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequestFilterAccountsFilterMemcmp.bytes)
  if (data_case() != kBytes) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.bytes_.Release();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_allocated_bytes(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_bytes();
    _impl_.data_.bytes_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeRequestFilterAccountsFilterMemcmp.bytes)
}

// string base58 = 3;
inline bool SubscribeRequestFilterAccountsFilterMemcmp::has_base58() const {
  return data_case() == kBase58;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_has_base58() {
  _impl_._oneof_case_[0] = kBase58;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::clear_base58() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() == kBase58) {
    _impl_.data_.base58_.Destroy();
    clear_has_data();
  }
}
inline const ::std::string& SubscribeRequestFilterAccountsFilterMemcmp::base58() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base58)
  return _internal_base58();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeRequestFilterAccountsFilterMemcmp::set_base58(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBase58) {
    clear_data();

    set_has_base58();
    _impl_.data_.base58_.InitDefault();
  }
  _impl_.data_.base58_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base58)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilterMemcmp::mutable_base58()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_base58();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base58)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterAccountsFilterMemcmp::_internal_base58() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (data_case() != kBase58) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.base58_.Get();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::_internal_set_base58(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBase58) {
    clear_data();

    set_has_base58();
    _impl_.data_.base58_.InitDefault();
  }
  _impl_.data_.base58_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilterMemcmp::_internal_mutable_base58() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBase58) {
    clear_data();

    set_has_base58();
    _impl_.data_.base58_.InitDefault();
  }
  return _impl_.data_.base58_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilterMemcmp::release_base58() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base58)
  if (data_case() != kBase58) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.base58_.Release();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_allocated_base58(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_base58();
    _impl_.data_.base58_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base58)
}

// string base64 = 4;
inline bool SubscribeRequestFilterAccountsFilterMemcmp::has_base64() const {
  return data_case() == kBase64;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_has_base64() {
  _impl_._oneof_case_[0] = kBase64;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::clear_base64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() == kBase64) {
    _impl_.data_.base64_.Destroy();
    clear_has_data();
  }
}
inline const ::std::string& SubscribeRequestFilterAccountsFilterMemcmp::base64() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base64)
  return _internal_base64();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeRequestFilterAccountsFilterMemcmp::set_base64(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBase64) {
    clear_data();

    set_has_base64();
    _impl_.data_.base64_.InitDefault();
  }
  _impl_.data_.base64_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base64)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilterMemcmp::mutable_base64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_base64();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base64)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterAccountsFilterMemcmp::_internal_base64() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (data_case() != kBase64) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.base64_.Get();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::_internal_set_base64(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBase64) {
    clear_data();

    set_has_base64();
    _impl_.data_.base64_.InitDefault();
  }
  _impl_.data_.base64_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterAccountsFilterMemcmp::_internal_mutable_base64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_case() != kBase64) {
    clear_data();

    set_has_base64();
    _impl_.data_.base64_.InitDefault();
  }
  return _impl_.data_.base64_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeRequestFilterAccountsFilterMemcmp::release_base64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base64)
  if (data_case() != kBase64) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.base64_.Release();
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::set_allocated_base64(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_base64();
    _impl_.data_.base64_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeRequestFilterAccountsFilterMemcmp.base64)
}

inline bool SubscribeRequestFilterAccountsFilterMemcmp::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SubscribeRequestFilterAccountsFilterMemcmp::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline SubscribeRequestFilterAccountsFilterMemcmp::DataCase SubscribeRequestFilterAccountsFilterMemcmp::data_case() const {
  return SubscribeRequestFilterAccountsFilterMemcmp::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SubscribeRequestFilterAccountsFilterLamports

// uint64 eq = 1;
inline bool SubscribeRequestFilterAccountsFilterLamports::has_eq() const {
  return cmp_case() == kEq;
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_has_eq() {
  _impl_._oneof_case_[0] = kEq;
}
inline void SubscribeRequestFilterAccountsFilterLamports::clear_eq() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmp_case() == kEq) {
    _impl_.cmp_.eq_ = ::uint64_t{0u};
    clear_has_cmp();
  }
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::eq() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterLamports.eq)
  return _internal_eq();
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_eq(::uint64_t value) {
  if (cmp_case() != kEq) {
    clear_cmp();
    set_has_eq();
  }
  _impl_.cmp_.eq_ = value;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterLamports.eq)
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::_internal_eq() const {
  if (cmp_case() == kEq) {
    return _impl_.cmp_.eq_;
  }
  return ::uint64_t{0u};
}

// uint64 ne = 2;
inline bool SubscribeRequestFilterAccountsFilterLamports::has_ne() const {
  return cmp_case() == kNe;
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_has_ne() {
  _impl_._oneof_case_[0] = kNe;
}
inline void SubscribeRequestFilterAccountsFilterLamports::clear_ne() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmp_case() == kNe) {
    _impl_.cmp_.ne_ = ::uint64_t{0u};
    clear_has_cmp();
  }
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::ne() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterLamports.ne)
  return _internal_ne();
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_ne(::uint64_t value) {
  if (cmp_case() != kNe) {
    clear_cmp();
    set_has_ne();
  }
  _impl_.cmp_.ne_ = value;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterLamports.ne)
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::_internal_ne() const {
  if (cmp_case() == kNe) {
    return _impl_.cmp_.ne_;
  }
  return ::uint64_t{0u};
}

// uint64 lt = 3;
inline bool SubscribeRequestFilterAccountsFilterLamports::has_lt() const {
  return cmp_case() == kLt;
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SubscribeRequestFilterAccountsFilterLamports::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmp_case() == kLt) {
    _impl_.cmp_.lt_ = ::uint64_t{0u};
    clear_has_cmp();
  }
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::lt() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterLamports.lt)
  return _internal_lt();
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_lt(::uint64_t value) {
  if (cmp_case() != kLt) {
    clear_cmp();
    set_has_lt();
  }
  _impl_.cmp_.lt_ = value;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterLamports.lt)
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::_internal_lt() const {
  if (cmp_case() == kLt) {
    return _impl_.cmp_.lt_;
  }
  return ::uint64_t{0u};
}

// uint64 gt = 4;
inline bool SubscribeRequestFilterAccountsFilterLamports::has_gt() const {
  return cmp_case() == kGt;
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_has_gt() {
  _impl_._oneof_case_[0] = kGt;
}
inline void SubscribeRequestFilterAccountsFilterLamports::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmp_case() == kGt) {
    _impl_.cmp_.gt_ = ::uint64_t{0u};
    clear_has_cmp();
  }
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::gt() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterAccountsFilterLamports.gt)
  return _internal_gt();
}
inline void SubscribeRequestFilterAccountsFilterLamports::set_gt(::uint64_t value) {
  if (cmp_case() != kGt) {
    clear_cmp();
    set_has_gt();
  }
  _impl_.cmp_.gt_ = value;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterAccountsFilterLamports.gt)
}
inline ::uint64_t SubscribeRequestFilterAccountsFilterLamports::_internal_gt() const {
  if (cmp_case() == kGt) {
    return _impl_.cmp_.gt_;
  }
  return ::uint64_t{0u};
}

inline bool SubscribeRequestFilterAccountsFilterLamports::has_cmp() const {
  return cmp_case() != CMP_NOT_SET;
}
inline void SubscribeRequestFilterAccountsFilterLamports::clear_has_cmp() {
  _impl_._oneof_case_[0] = CMP_NOT_SET;
}
inline SubscribeRequestFilterAccountsFilterLamports::CmpCase SubscribeRequestFilterAccountsFilterLamports::cmp_case() const {
  return SubscribeRequestFilterAccountsFilterLamports::CmpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SubscribeRequestFilterSlots

// optional bool filter_by_commitment = 1;
inline bool SubscribeRequestFilterSlots::has_filter_by_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SubscribeRequestFilterSlots::clear_filter_by_commitment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_by_commitment_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SubscribeRequestFilterSlots::filter_by_commitment() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterSlots.filter_by_commitment)
  return _internal_filter_by_commitment();
}
inline void SubscribeRequestFilterSlots::set_filter_by_commitment(bool value) {
  _internal_set_filter_by_commitment(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterSlots.filter_by_commitment)
}
inline bool SubscribeRequestFilterSlots::_internal_filter_by_commitment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_by_commitment_;
}
inline void SubscribeRequestFilterSlots::_internal_set_filter_by_commitment(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_by_commitment_ = value;
}

// optional bool interslot_updates = 2;
inline bool SubscribeRequestFilterSlots::has_interslot_updates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SubscribeRequestFilterSlots::clear_interslot_updates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interslot_updates_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SubscribeRequestFilterSlots::interslot_updates() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterSlots.interslot_updates)
  return _internal_interslot_updates();
}
inline void SubscribeRequestFilterSlots::set_interslot_updates(bool value) {
  _internal_set_interslot_updates(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterSlots.interslot_updates)
}
inline bool SubscribeRequestFilterSlots::_internal_interslot_updates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.interslot_updates_;
}
inline void SubscribeRequestFilterSlots::_internal_set_interslot_updates(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interslot_updates_ = value;
}

// -------------------------------------------------------------------

// SubscribeRequestFilterTransactions

// optional bool vote = 1;
inline bool SubscribeRequestFilterTransactions::has_vote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SubscribeRequestFilterTransactions::clear_vote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vote_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SubscribeRequestFilterTransactions::vote() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterTransactions.vote)
  return _internal_vote();
}
inline void SubscribeRequestFilterTransactions::set_vote(bool value) {
  _internal_set_vote(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterTransactions.vote)
}
inline bool SubscribeRequestFilterTransactions::_internal_vote() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vote_;
}
inline void SubscribeRequestFilterTransactions::_internal_set_vote(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vote_ = value;
}

// optional bool failed = 2;
inline bool SubscribeRequestFilterTransactions::has_failed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SubscribeRequestFilterTransactions::clear_failed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SubscribeRequestFilterTransactions::failed() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterTransactions.failed)
  return _internal_failed();
}
inline void SubscribeRequestFilterTransactions::set_failed(bool value) {
  _internal_set_failed(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterTransactions.failed)
}
inline bool SubscribeRequestFilterTransactions::_internal_failed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failed_;
}
inline void SubscribeRequestFilterTransactions::_internal_set_failed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_ = value;
}

// optional string signature = 5;
inline bool SubscribeRequestFilterTransactions::has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SubscribeRequestFilterTransactions::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeRequestFilterTransactions::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterTransactions.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeRequestFilterTransactions::set_signature(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterTransactions.signature)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::mutable_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterTransactions.signature)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterTransactions::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void SubscribeRequestFilterTransactions::_internal_set_signature(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeRequestFilterTransactions::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeRequestFilterTransactions.signature)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.signature_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.signature_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeRequestFilterTransactions::set_allocated_signature(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeRequestFilterTransactions.signature)
}

// repeated string account_include = 3;
inline int SubscribeRequestFilterTransactions::_internal_account_include_size() const {
  return _internal_account_include().size();
}
inline int SubscribeRequestFilterTransactions::account_include_size() const {
  return _internal_account_include_size();
}
inline void SubscribeRequestFilterTransactions::clear_account_include() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_include_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::add_account_include()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_account_include()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeRequestFilterTransactions.account_include)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterTransactions::account_include(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterTransactions.account_include)
  return _internal_account_include().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::mutable_account_include(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterTransactions.account_include)
  return _internal_mutable_account_include()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterTransactions::set_account_include(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_account_include()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterTransactions.account_include)
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterTransactions::add_account_include(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_account_include(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterTransactions.account_include)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeRequestFilterTransactions::account_include()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterTransactions.account_include)
  return _internal_account_include();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterTransactions::mutable_account_include() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterTransactions.account_include)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_account_include();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeRequestFilterTransactions::_internal_account_include() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_include_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterTransactions::_internal_mutable_account_include() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.account_include_;
}

// repeated string account_exclude = 4;
inline int SubscribeRequestFilterTransactions::_internal_account_exclude_size() const {
  return _internal_account_exclude().size();
}
inline int SubscribeRequestFilterTransactions::account_exclude_size() const {
  return _internal_account_exclude_size();
}
inline void SubscribeRequestFilterTransactions::clear_account_exclude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_exclude_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::add_account_exclude()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_account_exclude()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeRequestFilterTransactions.account_exclude)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterTransactions::account_exclude(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterTransactions.account_exclude)
  return _internal_account_exclude().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::mutable_account_exclude(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterTransactions.account_exclude)
  return _internal_mutable_account_exclude()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterTransactions::set_account_exclude(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_account_exclude()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterTransactions.account_exclude)
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterTransactions::add_account_exclude(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_account_exclude(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterTransactions.account_exclude)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeRequestFilterTransactions::account_exclude()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterTransactions.account_exclude)
  return _internal_account_exclude();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterTransactions::mutable_account_exclude() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterTransactions.account_exclude)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_account_exclude();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeRequestFilterTransactions::_internal_account_exclude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_exclude_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterTransactions::_internal_mutable_account_exclude() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.account_exclude_;
}

// repeated string account_required = 6;
inline int SubscribeRequestFilterTransactions::_internal_account_required_size() const {
  return _internal_account_required().size();
}
inline int SubscribeRequestFilterTransactions::account_required_size() const {
  return _internal_account_required_size();
}
inline void SubscribeRequestFilterTransactions::clear_account_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_required_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::add_account_required()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_account_required()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeRequestFilterTransactions.account_required)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterTransactions::account_required(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterTransactions.account_required)
  return _internal_account_required().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterTransactions::mutable_account_required(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterTransactions.account_required)
  return _internal_mutable_account_required()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterTransactions::set_account_required(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_account_required()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterTransactions.account_required)
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterTransactions::add_account_required(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_account_required(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterTransactions.account_required)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeRequestFilterTransactions::account_required()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterTransactions.account_required)
  return _internal_account_required();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterTransactions::mutable_account_required() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterTransactions.account_required)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_account_required();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeRequestFilterTransactions::_internal_account_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_required_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterTransactions::_internal_mutable_account_required() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.account_required_;
}

// -------------------------------------------------------------------

// SubscribeRequestFilterBlocks

// repeated string account_include = 1;
inline int SubscribeRequestFilterBlocks::_internal_account_include_size() const {
  return _internal_account_include().size();
}
inline int SubscribeRequestFilterBlocks::account_include_size() const {
  return _internal_account_include_size();
}
inline void SubscribeRequestFilterBlocks::clear_account_include() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_include_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterBlocks::add_account_include()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_account_include()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeRequestFilterBlocks.account_include)
  return _s;
}
inline const ::std::string& SubscribeRequestFilterBlocks::account_include(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterBlocks.account_include)
  return _internal_account_include().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeRequestFilterBlocks::mutable_account_include(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeRequestFilterBlocks.account_include)
  return _internal_mutable_account_include()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterBlocks::set_account_include(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_account_include()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterBlocks.account_include)
}
template <typename Arg_, typename... Args_>
inline void SubscribeRequestFilterBlocks::add_account_include(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_account_include(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeRequestFilterBlocks.account_include)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeRequestFilterBlocks::account_include()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeRequestFilterBlocks.account_include)
  return _internal_account_include();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterBlocks::mutable_account_include() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeRequestFilterBlocks.account_include)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_account_include();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeRequestFilterBlocks::_internal_account_include() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_include_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeRequestFilterBlocks::_internal_mutable_account_include() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.account_include_;
}

// optional bool include_transactions = 2;
inline bool SubscribeRequestFilterBlocks::has_include_transactions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SubscribeRequestFilterBlocks::clear_include_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_transactions_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SubscribeRequestFilterBlocks::include_transactions() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterBlocks.include_transactions)
  return _internal_include_transactions();
}
inline void SubscribeRequestFilterBlocks::set_include_transactions(bool value) {
  _internal_set_include_transactions(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterBlocks.include_transactions)
}
inline bool SubscribeRequestFilterBlocks::_internal_include_transactions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_transactions_;
}
inline void SubscribeRequestFilterBlocks::_internal_set_include_transactions(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_transactions_ = value;
}

// optional bool include_accounts = 3;
inline bool SubscribeRequestFilterBlocks::has_include_accounts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SubscribeRequestFilterBlocks::clear_include_accounts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_accounts_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SubscribeRequestFilterBlocks::include_accounts() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterBlocks.include_accounts)
  return _internal_include_accounts();
}
inline void SubscribeRequestFilterBlocks::set_include_accounts(bool value) {
  _internal_set_include_accounts(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterBlocks.include_accounts)
}
inline bool SubscribeRequestFilterBlocks::_internal_include_accounts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_accounts_;
}
inline void SubscribeRequestFilterBlocks::_internal_set_include_accounts(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_accounts_ = value;
}

// optional bool include_entries = 4;
inline bool SubscribeRequestFilterBlocks::has_include_entries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SubscribeRequestFilterBlocks::clear_include_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_entries_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SubscribeRequestFilterBlocks::include_entries() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestFilterBlocks.include_entries)
  return _internal_include_entries();
}
inline void SubscribeRequestFilterBlocks::set_include_entries(bool value) {
  _internal_set_include_entries(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestFilterBlocks.include_entries)
}
inline bool SubscribeRequestFilterBlocks::_internal_include_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_entries_;
}
inline void SubscribeRequestFilterBlocks::_internal_set_include_entries(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_entries_ = value;
}

// -------------------------------------------------------------------

// SubscribeRequestFilterBlocksMeta

// -------------------------------------------------------------------

// SubscribeRequestFilterEntry

// -------------------------------------------------------------------

// SubscribeRequestAccountsDataSlice

// uint64 offset = 1;
inline void SubscribeRequestAccountsDataSlice::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SubscribeRequestAccountsDataSlice::offset() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestAccountsDataSlice.offset)
  return _internal_offset();
}
inline void SubscribeRequestAccountsDataSlice::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestAccountsDataSlice.offset)
}
inline ::uint64_t SubscribeRequestAccountsDataSlice::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void SubscribeRequestAccountsDataSlice::_internal_set_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// uint64 length = 2;
inline void SubscribeRequestAccountsDataSlice::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SubscribeRequestAccountsDataSlice::length() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestAccountsDataSlice.length)
  return _internal_length();
}
inline void SubscribeRequestAccountsDataSlice::set_length(::uint64_t value) {
  _internal_set_length(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestAccountsDataSlice.length)
}
inline ::uint64_t SubscribeRequestAccountsDataSlice::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_;
}
inline void SubscribeRequestAccountsDataSlice::_internal_set_length(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// -------------------------------------------------------------------

// SubscribeRequestPing

// int32 id = 1;
inline void SubscribeRequestPing::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SubscribeRequestPing::id() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeRequestPing.id)
  return _internal_id();
}
inline void SubscribeRequestPing::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeRequestPing.id)
}
inline ::int32_t SubscribeRequestPing::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void SubscribeRequestPing::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// SubscribeUpdate

// repeated string filters = 1;
inline int SubscribeUpdate::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int SubscribeUpdate::filters_size() const {
  return _internal_filters_size();
}
inline void SubscribeUpdate::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filters_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdate::add_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add_mutable:geyser.SubscribeUpdate.filters)
  return _s;
}
inline const ::std::string& SubscribeUpdate::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.filters)
  return _internal_filters().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdate::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.filters)
  return _internal_mutable_filters()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubscribeUpdate::set_filters(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_filters()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdate.filters)
}
template <typename Arg_, typename... Args_>
inline void SubscribeUpdate::add_filters(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_filters(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:geyser.SubscribeUpdate.filters)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubscribeUpdate::filters()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeUpdate.filters)
  return _internal_filters();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeUpdate::mutable_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeUpdate.filters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_filters();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubscribeUpdate::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubscribeUpdate::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.filters_;
}

// .geyser.SubscribeUpdateAccount account = 2;
inline bool SubscribeUpdate::has_account() const {
  return update_oneof_case() == kAccount;
}
inline bool SubscribeUpdate::_internal_has_account() const {
  return update_oneof_case() == kAccount;
}
inline void SubscribeUpdate::set_has_account() {
  _impl_._oneof_case_[0] = kAccount;
}
inline void SubscribeUpdate::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kAccount) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.account_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.account_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE SubscribeUpdate::release_account() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.account)
  if (update_oneof_case() == kAccount) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateAccount*>(_impl_.update_oneof_.account_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateAccount& SubscribeUpdate::_internal_account() const {
  return update_oneof_case() == kAccount ? *reinterpret_cast<::geyser::SubscribeUpdateAccount*>(_impl_.update_oneof_.account_) : reinterpret_cast<::geyser::SubscribeUpdateAccount&>(::geyser::_SubscribeUpdateAccount_default_instance_);
}
inline const ::geyser::SubscribeUpdateAccount& SubscribeUpdate::account() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.account)
  return _internal_account();
}
inline ::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.account)
  if (update_oneof_case() == kAccount) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateAccount*>(_impl_.update_oneof_.account_);
    _impl_.update_oneof_.account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_account(
    ::geyser::SubscribeUpdateAccount* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_account();
    _impl_.update_oneof_.account_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.account)
}
inline ::geyser::SubscribeUpdateAccount* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_account() {
  if (update_oneof_case() != kAccount) {
    clear_update_oneof();
    set_has_account();
    _impl_.update_oneof_.account_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateAccount>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateAccount*>(_impl_.update_oneof_.account_);
}
inline ::geyser::SubscribeUpdateAccount* PROTOBUF_NONNULL SubscribeUpdate::mutable_account()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateAccount* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.account)
  return _msg;
}

// .geyser.SubscribeUpdateSlot slot = 3;
inline bool SubscribeUpdate::has_slot() const {
  return update_oneof_case() == kSlot;
}
inline bool SubscribeUpdate::_internal_has_slot() const {
  return update_oneof_case() == kSlot;
}
inline void SubscribeUpdate::set_has_slot() {
  _impl_._oneof_case_[0] = kSlot;
}
inline void SubscribeUpdate::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kSlot) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.slot_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.slot_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE SubscribeUpdate::release_slot() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.slot)
  if (update_oneof_case() == kSlot) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateSlot*>(_impl_.update_oneof_.slot_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.slot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateSlot& SubscribeUpdate::_internal_slot() const {
  return update_oneof_case() == kSlot ? *reinterpret_cast<::geyser::SubscribeUpdateSlot*>(_impl_.update_oneof_.slot_) : reinterpret_cast<::geyser::SubscribeUpdateSlot&>(::geyser::_SubscribeUpdateSlot_default_instance_);
}
inline const ::geyser::SubscribeUpdateSlot& SubscribeUpdate::slot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.slot)
  return _internal_slot();
}
inline ::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_slot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.slot)
  if (update_oneof_case() == kSlot) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateSlot*>(_impl_.update_oneof_.slot_);
    _impl_.update_oneof_.slot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_slot(
    ::geyser::SubscribeUpdateSlot* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_slot();
    _impl_.update_oneof_.slot_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.slot)
}
inline ::geyser::SubscribeUpdateSlot* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_slot() {
  if (update_oneof_case() != kSlot) {
    clear_update_oneof();
    set_has_slot();
    _impl_.update_oneof_.slot_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateSlot>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateSlot*>(_impl_.update_oneof_.slot_);
}
inline ::geyser::SubscribeUpdateSlot* PROTOBUF_NONNULL SubscribeUpdate::mutable_slot()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateSlot* _msg = _internal_mutable_slot();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.slot)
  return _msg;
}

// .geyser.SubscribeUpdateTransaction transaction = 4;
inline bool SubscribeUpdate::has_transaction() const {
  return update_oneof_case() == kTransaction;
}
inline bool SubscribeUpdate::_internal_has_transaction() const {
  return update_oneof_case() == kTransaction;
}
inline void SubscribeUpdate::set_has_transaction() {
  _impl_._oneof_case_[0] = kTransaction;
}
inline void SubscribeUpdate::clear_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kTransaction) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.transaction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.transaction_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE SubscribeUpdate::release_transaction() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.transaction)
  if (update_oneof_case() == kTransaction) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateTransaction*>(_impl_.update_oneof_.transaction_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateTransaction& SubscribeUpdate::_internal_transaction() const {
  return update_oneof_case() == kTransaction ? *reinterpret_cast<::geyser::SubscribeUpdateTransaction*>(_impl_.update_oneof_.transaction_) : reinterpret_cast<::geyser::SubscribeUpdateTransaction&>(::geyser::_SubscribeUpdateTransaction_default_instance_);
}
inline const ::geyser::SubscribeUpdateTransaction& SubscribeUpdate::transaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.transaction)
  return _internal_transaction();
}
inline ::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.transaction)
  if (update_oneof_case() == kTransaction) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateTransaction*>(_impl_.update_oneof_.transaction_);
    _impl_.update_oneof_.transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_transaction(
    ::geyser::SubscribeUpdateTransaction* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_transaction();
    _impl_.update_oneof_.transaction_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.transaction)
}
inline ::geyser::SubscribeUpdateTransaction* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_transaction() {
  if (update_oneof_case() != kTransaction) {
    clear_update_oneof();
    set_has_transaction();
    _impl_.update_oneof_.transaction_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateTransaction>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateTransaction*>(_impl_.update_oneof_.transaction_);
}
inline ::geyser::SubscribeUpdateTransaction* PROTOBUF_NONNULL SubscribeUpdate::mutable_transaction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateTransaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.transaction)
  return _msg;
}

// .geyser.SubscribeUpdateTransactionStatus transaction_status = 10;
inline bool SubscribeUpdate::has_transaction_status() const {
  return update_oneof_case() == kTransactionStatus;
}
inline bool SubscribeUpdate::_internal_has_transaction_status() const {
  return update_oneof_case() == kTransactionStatus;
}
inline void SubscribeUpdate::set_has_transaction_status() {
  _impl_._oneof_case_[0] = kTransactionStatus;
}
inline void SubscribeUpdate::clear_transaction_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kTransactionStatus) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.transaction_status_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.transaction_status_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE SubscribeUpdate::release_transaction_status() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.transaction_status)
  if (update_oneof_case() == kTransactionStatus) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateTransactionStatus*>(_impl_.update_oneof_.transaction_status_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.transaction_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateTransactionStatus& SubscribeUpdate::_internal_transaction_status() const {
  return update_oneof_case() == kTransactionStatus ? *reinterpret_cast<::geyser::SubscribeUpdateTransactionStatus*>(_impl_.update_oneof_.transaction_status_) : reinterpret_cast<::geyser::SubscribeUpdateTransactionStatus&>(::geyser::_SubscribeUpdateTransactionStatus_default_instance_);
}
inline const ::geyser::SubscribeUpdateTransactionStatus& SubscribeUpdate::transaction_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.transaction_status)
  return _internal_transaction_status();
}
inline ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_transaction_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.transaction_status)
  if (update_oneof_case() == kTransactionStatus) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateTransactionStatus*>(_impl_.update_oneof_.transaction_status_);
    _impl_.update_oneof_.transaction_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_transaction_status(
    ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_transaction_status();
    _impl_.update_oneof_.transaction_status_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.transaction_status)
}
inline ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_transaction_status() {
  if (update_oneof_case() != kTransactionStatus) {
    clear_update_oneof();
    set_has_transaction_status();
    _impl_.update_oneof_.transaction_status_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateTransactionStatus>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateTransactionStatus*>(_impl_.update_oneof_.transaction_status_);
}
inline ::geyser::SubscribeUpdateTransactionStatus* PROTOBUF_NONNULL SubscribeUpdate::mutable_transaction_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateTransactionStatus* _msg = _internal_mutable_transaction_status();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.transaction_status)
  return _msg;
}

// .geyser.SubscribeUpdateBlock block = 5;
inline bool SubscribeUpdate::has_block() const {
  return update_oneof_case() == kBlock;
}
inline bool SubscribeUpdate::_internal_has_block() const {
  return update_oneof_case() == kBlock;
}
inline void SubscribeUpdate::set_has_block() {
  _impl_._oneof_case_[0] = kBlock;
}
inline void SubscribeUpdate::clear_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kBlock) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.block_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.block_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE SubscribeUpdate::release_block() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.block)
  if (update_oneof_case() == kBlock) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateBlock*>(_impl_.update_oneof_.block_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateBlock& SubscribeUpdate::_internal_block() const {
  return update_oneof_case() == kBlock ? *reinterpret_cast<::geyser::SubscribeUpdateBlock*>(_impl_.update_oneof_.block_) : reinterpret_cast<::geyser::SubscribeUpdateBlock&>(::geyser::_SubscribeUpdateBlock_default_instance_);
}
inline const ::geyser::SubscribeUpdateBlock& SubscribeUpdate::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.block)
  return _internal_block();
}
inline ::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.block)
  if (update_oneof_case() == kBlock) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateBlock*>(_impl_.update_oneof_.block_);
    _impl_.update_oneof_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_block(
    ::geyser::SubscribeUpdateBlock* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_block();
    _impl_.update_oneof_.block_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.block)
}
inline ::geyser::SubscribeUpdateBlock* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_block() {
  if (update_oneof_case() != kBlock) {
    clear_update_oneof();
    set_has_block();
    _impl_.update_oneof_.block_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateBlock>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateBlock*>(_impl_.update_oneof_.block_);
}
inline ::geyser::SubscribeUpdateBlock* PROTOBUF_NONNULL SubscribeUpdate::mutable_block()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateBlock* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.block)
  return _msg;
}

// .geyser.SubscribeUpdatePing ping = 6;
inline bool SubscribeUpdate::has_ping() const {
  return update_oneof_case() == kPing;
}
inline bool SubscribeUpdate::_internal_has_ping() const {
  return update_oneof_case() == kPing;
}
inline void SubscribeUpdate::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void SubscribeUpdate::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kPing) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.ping_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.ping_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE SubscribeUpdate::release_ping() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.ping)
  if (update_oneof_case() == kPing) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdatePing*>(_impl_.update_oneof_.ping_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdatePing& SubscribeUpdate::_internal_ping() const {
  return update_oneof_case() == kPing ? *reinterpret_cast<::geyser::SubscribeUpdatePing*>(_impl_.update_oneof_.ping_) : reinterpret_cast<::geyser::SubscribeUpdatePing&>(::geyser::_SubscribeUpdatePing_default_instance_);
}
inline const ::geyser::SubscribeUpdatePing& SubscribeUpdate::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.ping)
  return _internal_ping();
}
inline ::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.ping)
  if (update_oneof_case() == kPing) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdatePing*>(_impl_.update_oneof_.ping_);
    _impl_.update_oneof_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_ping(
    ::geyser::SubscribeUpdatePing* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_ping();
    _impl_.update_oneof_.ping_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.ping)
}
inline ::geyser::SubscribeUpdatePing* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_ping() {
  if (update_oneof_case() != kPing) {
    clear_update_oneof();
    set_has_ping();
    _impl_.update_oneof_.ping_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdatePing>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdatePing*>(_impl_.update_oneof_.ping_);
}
inline ::geyser::SubscribeUpdatePing* PROTOBUF_NONNULL SubscribeUpdate::mutable_ping()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdatePing* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.ping)
  return _msg;
}

// .geyser.SubscribeUpdatePong pong = 9;
inline bool SubscribeUpdate::has_pong() const {
  return update_oneof_case() == kPong;
}
inline bool SubscribeUpdate::_internal_has_pong() const {
  return update_oneof_case() == kPong;
}
inline void SubscribeUpdate::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void SubscribeUpdate::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kPong) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.pong_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.pong_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE SubscribeUpdate::release_pong() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.pong)
  if (update_oneof_case() == kPong) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdatePong*>(_impl_.update_oneof_.pong_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdatePong& SubscribeUpdate::_internal_pong() const {
  return update_oneof_case() == kPong ? *reinterpret_cast<::geyser::SubscribeUpdatePong*>(_impl_.update_oneof_.pong_) : reinterpret_cast<::geyser::SubscribeUpdatePong&>(::geyser::_SubscribeUpdatePong_default_instance_);
}
inline const ::geyser::SubscribeUpdatePong& SubscribeUpdate::pong() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.pong)
  return _internal_pong();
}
inline ::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.pong)
  if (update_oneof_case() == kPong) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdatePong*>(_impl_.update_oneof_.pong_);
    _impl_.update_oneof_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_pong(
    ::geyser::SubscribeUpdatePong* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_pong();
    _impl_.update_oneof_.pong_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.pong)
}
inline ::geyser::SubscribeUpdatePong* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_pong() {
  if (update_oneof_case() != kPong) {
    clear_update_oneof();
    set_has_pong();
    _impl_.update_oneof_.pong_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdatePong>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdatePong*>(_impl_.update_oneof_.pong_);
}
inline ::geyser::SubscribeUpdatePong* PROTOBUF_NONNULL SubscribeUpdate::mutable_pong()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdatePong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.pong)
  return _msg;
}

// .geyser.SubscribeUpdateBlockMeta block_meta = 7;
inline bool SubscribeUpdate::has_block_meta() const {
  return update_oneof_case() == kBlockMeta;
}
inline bool SubscribeUpdate::_internal_has_block_meta() const {
  return update_oneof_case() == kBlockMeta;
}
inline void SubscribeUpdate::set_has_block_meta() {
  _impl_._oneof_case_[0] = kBlockMeta;
}
inline void SubscribeUpdate::clear_block_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kBlockMeta) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.block_meta_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.block_meta_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE SubscribeUpdate::release_block_meta() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.block_meta)
  if (update_oneof_case() == kBlockMeta) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateBlockMeta*>(_impl_.update_oneof_.block_meta_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.block_meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateBlockMeta& SubscribeUpdate::_internal_block_meta() const {
  return update_oneof_case() == kBlockMeta ? *reinterpret_cast<::geyser::SubscribeUpdateBlockMeta*>(_impl_.update_oneof_.block_meta_) : reinterpret_cast<::geyser::SubscribeUpdateBlockMeta&>(::geyser::_SubscribeUpdateBlockMeta_default_instance_);
}
inline const ::geyser::SubscribeUpdateBlockMeta& SubscribeUpdate::block_meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.block_meta)
  return _internal_block_meta();
}
inline ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_block_meta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.block_meta)
  if (update_oneof_case() == kBlockMeta) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateBlockMeta*>(_impl_.update_oneof_.block_meta_);
    _impl_.update_oneof_.block_meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_block_meta(
    ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_block_meta();
    _impl_.update_oneof_.block_meta_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.block_meta)
}
inline ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_block_meta() {
  if (update_oneof_case() != kBlockMeta) {
    clear_update_oneof();
    set_has_block_meta();
    _impl_.update_oneof_.block_meta_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateBlockMeta>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateBlockMeta*>(_impl_.update_oneof_.block_meta_);
}
inline ::geyser::SubscribeUpdateBlockMeta* PROTOBUF_NONNULL SubscribeUpdate::mutable_block_meta()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateBlockMeta* _msg = _internal_mutable_block_meta();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.block_meta)
  return _msg;
}

// .geyser.SubscribeUpdateEntry entry = 8;
inline bool SubscribeUpdate::has_entry() const {
  return update_oneof_case() == kEntry;
}
inline bool SubscribeUpdate::_internal_has_entry() const {
  return update_oneof_case() == kEntry;
}
inline void SubscribeUpdate::set_has_entry() {
  _impl_._oneof_case_[0] = kEntry;
}
inline void SubscribeUpdate::clear_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_oneof_case() == kEntry) {
    if (GetArena() == nullptr) {
      delete _impl_.update_oneof_.entry_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_oneof_.entry_);
    }
    clear_has_update_oneof();
  }
}
inline ::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE SubscribeUpdate::release_entry() {
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.entry)
  if (update_oneof_case() == kEntry) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateEntry*>(_impl_.update_oneof_.entry_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_oneof_.entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::geyser::SubscribeUpdateEntry& SubscribeUpdate::_internal_entry() const {
  return update_oneof_case() == kEntry ? *reinterpret_cast<::geyser::SubscribeUpdateEntry*>(_impl_.update_oneof_.entry_) : reinterpret_cast<::geyser::SubscribeUpdateEntry&>(::geyser::_SubscribeUpdateEntry_default_instance_);
}
inline const ::geyser::SubscribeUpdateEntry& SubscribeUpdate::entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.entry)
  return _internal_entry();
}
inline ::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:geyser.SubscribeUpdate.entry)
  if (update_oneof_case() == kEntry) {
    clear_has_update_oneof();
    auto* temp = reinterpret_cast<::geyser::SubscribeUpdateEntry*>(_impl_.update_oneof_.entry_);
    _impl_.update_oneof_.entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_entry(
    ::geyser::SubscribeUpdateEntry* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update_oneof();
  if (value) {
    set_has_entry();
    _impl_.update_oneof_.entry_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.entry)
}
inline ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_entry() {
  if (update_oneof_case() != kEntry) {
    clear_update_oneof();
    set_has_entry();
    _impl_.update_oneof_.entry_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateEntry>(GetArena()));
  }
  return reinterpret_cast<::geyser::SubscribeUpdateEntry*>(_impl_.update_oneof_.entry_);
}
inline ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL SubscribeUpdate::mutable_entry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::geyser::SubscribeUpdateEntry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.entry)
  return _msg;
}

// .google.protobuf.Timestamp created_at = 11;
inline bool SubscribeUpdate::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SubscribeUpdate::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SubscribeUpdate::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdate.created_at)
  return _internal_created_at();
}
inline void SubscribeUpdate::unsafe_arena_set_allocated_created_at(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdate.created_at)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE SubscribeUpdate::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE SubscribeUpdate::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdate.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL SubscribeUpdate::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL SubscribeUpdate::mutable_created_at()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdate.created_at)
  return _msg;
}
inline void SubscribeUpdate::set_allocated_created_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdate.created_at)
}

inline bool SubscribeUpdate::has_update_oneof() const {
  return update_oneof_case() != UPDATE_ONEOF_NOT_SET;
}
inline void SubscribeUpdate::clear_has_update_oneof() {
  _impl_._oneof_case_[0] = UPDATE_ONEOF_NOT_SET;
}
inline SubscribeUpdate::UpdateOneofCase SubscribeUpdate::update_oneof_case() const {
  return SubscribeUpdate::UpdateOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SubscribeUpdateAccount

// .geyser.SubscribeUpdateAccountInfo account = 1;
inline bool SubscribeUpdateAccount::has_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.account_ != nullptr);
  return value;
}
inline void SubscribeUpdateAccount::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.account_ != nullptr) _impl_.account_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geyser::SubscribeUpdateAccountInfo& SubscribeUpdateAccount::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::geyser::SubscribeUpdateAccountInfo* p = _impl_.account_;
  return p != nullptr ? *p : reinterpret_cast<const ::geyser::SubscribeUpdateAccountInfo&>(::geyser::_SubscribeUpdateAccountInfo_default_instance_);
}
inline const ::geyser::SubscribeUpdateAccountInfo& SubscribeUpdateAccount::account() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccount.account)
  return _internal_account();
}
inline void SubscribeUpdateAccount::unsafe_arena_set_allocated_account(
    ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.account_);
  }
  _impl_.account_ = reinterpret_cast<::geyser::SubscribeUpdateAccountInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateAccount.account)
}
inline ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE SubscribeUpdateAccount::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geyser::SubscribeUpdateAccountInfo* released = _impl_.account_;
  _impl_.account_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE SubscribeUpdateAccount::unsafe_arena_release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateAccount.account)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geyser::SubscribeUpdateAccountInfo* temp = _impl_.account_;
  _impl_.account_ = nullptr;
  return temp;
}
inline ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL SubscribeUpdateAccount::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.account_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateAccountInfo>(GetArena());
    _impl_.account_ = reinterpret_cast<::geyser::SubscribeUpdateAccountInfo*>(p);
  }
  return _impl_.account_;
}
inline ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL SubscribeUpdateAccount::mutable_account()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::geyser::SubscribeUpdateAccountInfo* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateAccount.account)
  return _msg;
}
inline void SubscribeUpdateAccount::set_allocated_account(::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.account_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.account_ = reinterpret_cast<::geyser::SubscribeUpdateAccountInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateAccount.account)
}

// uint64 slot = 2;
inline void SubscribeUpdateAccount::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SubscribeUpdateAccount::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccount.slot)
  return _internal_slot();
}
inline void SubscribeUpdateAccount::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccount.slot)
}
inline ::uint64_t SubscribeUpdateAccount::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateAccount::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// bool is_startup = 3;
inline void SubscribeUpdateAccount::clear_is_startup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_startup_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SubscribeUpdateAccount::is_startup() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccount.is_startup)
  return _internal_is_startup();
}
inline void SubscribeUpdateAccount::set_is_startup(bool value) {
  _internal_set_is_startup(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccount.is_startup)
}
inline bool SubscribeUpdateAccount::_internal_is_startup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_startup_;
}
inline void SubscribeUpdateAccount::_internal_set_is_startup(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_startup_ = value;
}

// -------------------------------------------------------------------

// SubscribeUpdateAccountInfo

// bytes pubkey = 1;
inline void SubscribeUpdateAccountInfo::clear_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pubkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateAccountInfo::pubkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.pubkey)
  return _internal_pubkey();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateAccountInfo::set_pubkey(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pubkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.pubkey)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::mutable_pubkey()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateAccountInfo.pubkey)
  return _s;
}
inline const ::std::string& SubscribeUpdateAccountInfo::_internal_pubkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pubkey_.Get();
}
inline void SubscribeUpdateAccountInfo::_internal_set_pubkey(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pubkey_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::_internal_mutable_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pubkey_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateAccountInfo::release_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateAccountInfo.pubkey)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.pubkey_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.pubkey_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateAccountInfo::set_allocated_pubkey(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pubkey_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pubkey_.IsDefault()) {
    _impl_.pubkey_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateAccountInfo.pubkey)
}

// uint64 lamports = 2;
inline void SubscribeUpdateAccountInfo::clear_lamports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lamports_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t SubscribeUpdateAccountInfo::lamports() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.lamports)
  return _internal_lamports();
}
inline void SubscribeUpdateAccountInfo::set_lamports(::uint64_t value) {
  _internal_set_lamports(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.lamports)
}
inline ::uint64_t SubscribeUpdateAccountInfo::_internal_lamports() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lamports_;
}
inline void SubscribeUpdateAccountInfo::_internal_set_lamports(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lamports_ = value;
}

// bytes owner = 3;
inline void SubscribeUpdateAccountInfo::clear_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SubscribeUpdateAccountInfo::owner() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateAccountInfo::set_owner(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.owner_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.owner)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::mutable_owner()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateAccountInfo.owner)
  return _s;
}
inline const ::std::string& SubscribeUpdateAccountInfo::_internal_owner() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.owner_.Get();
}
inline void SubscribeUpdateAccountInfo::_internal_set_owner(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.owner_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::_internal_mutable_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.owner_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateAccountInfo::release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateAccountInfo.owner)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.owner_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.owner_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateAccountInfo::set_allocated_owner(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.owner_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.owner_.IsDefault()) {
    _impl_.owner_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateAccountInfo.owner)
}

// bool executable = 4;
inline void SubscribeUpdateAccountInfo::clear_executable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executable_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool SubscribeUpdateAccountInfo::executable() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.executable)
  return _internal_executable();
}
inline void SubscribeUpdateAccountInfo::set_executable(bool value) {
  _internal_set_executable(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.executable)
}
inline bool SubscribeUpdateAccountInfo::_internal_executable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executable_;
}
inline void SubscribeUpdateAccountInfo::_internal_set_executable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executable_ = value;
}

// uint64 rent_epoch = 5;
inline void SubscribeUpdateAccountInfo::clear_rent_epoch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rent_epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t SubscribeUpdateAccountInfo::rent_epoch() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.rent_epoch)
  return _internal_rent_epoch();
}
inline void SubscribeUpdateAccountInfo::set_rent_epoch(::uint64_t value) {
  _internal_set_rent_epoch(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.rent_epoch)
}
inline ::uint64_t SubscribeUpdateAccountInfo::_internal_rent_epoch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rent_epoch_;
}
inline void SubscribeUpdateAccountInfo::_internal_set_rent_epoch(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rent_epoch_ = value;
}

// bytes data = 6;
inline void SubscribeUpdateAccountInfo::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& SubscribeUpdateAccountInfo::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateAccountInfo::set_data(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.data)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateAccountInfo.data)
  return _s;
}
inline const ::std::string& SubscribeUpdateAccountInfo::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void SubscribeUpdateAccountInfo::_internal_set_data(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.data_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateAccountInfo::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateAccountInfo.data)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateAccountInfo::set_allocated_data(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateAccountInfo.data)
}

// uint64 write_version = 7;
inline void SubscribeUpdateAccountInfo::clear_write_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_version_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t SubscribeUpdateAccountInfo::write_version() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.write_version)
  return _internal_write_version();
}
inline void SubscribeUpdateAccountInfo::set_write_version(::uint64_t value) {
  _internal_set_write_version(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.write_version)
}
inline ::uint64_t SubscribeUpdateAccountInfo::_internal_write_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.write_version_;
}
inline void SubscribeUpdateAccountInfo::_internal_set_write_version(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.write_version_ = value;
}

// optional bytes txn_signature = 8;
inline bool SubscribeUpdateAccountInfo::has_txn_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SubscribeUpdateAccountInfo::clear_txn_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.txn_signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& SubscribeUpdateAccountInfo::txn_signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateAccountInfo.txn_signature)
  return _internal_txn_signature();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateAccountInfo::set_txn_signature(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txn_signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateAccountInfo.txn_signature)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::mutable_txn_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_txn_signature();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateAccountInfo.txn_signature)
  return _s;
}
inline const ::std::string& SubscribeUpdateAccountInfo::_internal_txn_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.txn_signature_.Get();
}
inline void SubscribeUpdateAccountInfo::_internal_set_txn_signature(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txn_signature_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateAccountInfo::_internal_mutable_txn_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.txn_signature_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateAccountInfo::release_txn_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateAccountInfo.txn_signature)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.txn_signature_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.txn_signature_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateAccountInfo::set_allocated_txn_signature(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.txn_signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.txn_signature_.IsDefault()) {
    _impl_.txn_signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateAccountInfo.txn_signature)
}

// -------------------------------------------------------------------

// SubscribeUpdateSlot

// uint64 slot = 1;
inline void SubscribeUpdateSlot::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SubscribeUpdateSlot::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateSlot.slot)
  return _internal_slot();
}
inline void SubscribeUpdateSlot::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateSlot.slot)
}
inline ::uint64_t SubscribeUpdateSlot::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateSlot::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// optional uint64 parent = 2;
inline bool SubscribeUpdateSlot::has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SubscribeUpdateSlot::clear_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t SubscribeUpdateSlot::parent() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateSlot.parent)
  return _internal_parent();
}
inline void SubscribeUpdateSlot::set_parent(::uint64_t value) {
  _internal_set_parent(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateSlot.parent)
}
inline ::uint64_t SubscribeUpdateSlot::_internal_parent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_;
}
inline void SubscribeUpdateSlot::_internal_set_parent(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_ = value;
}

// .geyser.SlotStatus status = 3;
inline void SubscribeUpdateSlot::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::geyser::SlotStatus SubscribeUpdateSlot::status() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateSlot.status)
  return _internal_status();
}
inline void SubscribeUpdateSlot::set_status(::geyser::SlotStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateSlot.status)
}
inline ::geyser::SlotStatus SubscribeUpdateSlot::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::geyser::SlotStatus>(_impl_.status_);
}
inline void SubscribeUpdateSlot::_internal_set_status(::geyser::SlotStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// optional string dead_error = 4;
inline bool SubscribeUpdateSlot::has_dead_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SubscribeUpdateSlot::clear_dead_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dead_error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateSlot::dead_error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateSlot.dead_error)
  return _internal_dead_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateSlot::set_dead_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dead_error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateSlot.dead_error)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateSlot::mutable_dead_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_dead_error();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateSlot.dead_error)
  return _s;
}
inline const ::std::string& SubscribeUpdateSlot::_internal_dead_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dead_error_.Get();
}
inline void SubscribeUpdateSlot::_internal_set_dead_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dead_error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateSlot::_internal_mutable_dead_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dead_error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateSlot::release_dead_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateSlot.dead_error)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dead_error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dead_error_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateSlot::set_allocated_dead_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dead_error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dead_error_.IsDefault()) {
    _impl_.dead_error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateSlot.dead_error)
}

// -------------------------------------------------------------------

// SubscribeUpdateTransaction

// .geyser.SubscribeUpdateTransactionInfo transaction = 1;
inline bool SubscribeUpdateTransaction::has_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transaction_ != nullptr);
  return value;
}
inline void SubscribeUpdateTransaction::clear_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transaction_ != nullptr) _impl_.transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::geyser::SubscribeUpdateTransactionInfo& SubscribeUpdateTransaction::_internal_transaction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::geyser::SubscribeUpdateTransactionInfo* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::geyser::SubscribeUpdateTransactionInfo&>(::geyser::_SubscribeUpdateTransactionInfo_default_instance_);
}
inline const ::geyser::SubscribeUpdateTransactionInfo& SubscribeUpdateTransaction::transaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransaction.transaction)
  return _internal_transaction();
}
inline void SubscribeUpdateTransaction::unsafe_arena_set_allocated_transaction(
    ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = reinterpret_cast<::geyser::SubscribeUpdateTransactionInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateTransaction.transaction)
}
inline ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE SubscribeUpdateTransaction::release_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geyser::SubscribeUpdateTransactionInfo* released = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE SubscribeUpdateTransaction::unsafe_arena_release_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateTransaction.transaction)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::geyser::SubscribeUpdateTransactionInfo* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL SubscribeUpdateTransaction::_internal_mutable_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transaction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::geyser::SubscribeUpdateTransactionInfo>(GetArena());
    _impl_.transaction_ = reinterpret_cast<::geyser::SubscribeUpdateTransactionInfo*>(p);
  }
  return _impl_.transaction_;
}
inline ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL SubscribeUpdateTransaction::mutable_transaction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::geyser::SubscribeUpdateTransactionInfo* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateTransaction.transaction)
  return _msg;
}
inline void SubscribeUpdateTransaction::set_allocated_transaction(::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transaction_ = reinterpret_cast<::geyser::SubscribeUpdateTransactionInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateTransaction.transaction)
}

// uint64 slot = 2;
inline void SubscribeUpdateTransaction::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SubscribeUpdateTransaction::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransaction.slot)
  return _internal_slot();
}
inline void SubscribeUpdateTransaction::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransaction.slot)
}
inline ::uint64_t SubscribeUpdateTransaction::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateTransaction::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// -------------------------------------------------------------------

// SubscribeUpdateTransactionInfo

// bytes signature = 1;
inline void SubscribeUpdateTransactionInfo::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateTransactionInfo::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionInfo.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateTransactionInfo::set_signature(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionInfo.signature)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateTransactionInfo::mutable_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateTransactionInfo.signature)
  return _s;
}
inline const ::std::string& SubscribeUpdateTransactionInfo::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void SubscribeUpdateTransactionInfo::_internal_set_signature(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateTransactionInfo::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateTransactionInfo::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateTransactionInfo.signature)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.signature_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.signature_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateTransactionInfo::set_allocated_signature(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateTransactionInfo.signature)
}

// bool is_vote = 2;
inline void SubscribeUpdateTransactionInfo::clear_is_vote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_vote_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SubscribeUpdateTransactionInfo::is_vote() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionInfo.is_vote)
  return _internal_is_vote();
}
inline void SubscribeUpdateTransactionInfo::set_is_vote(bool value) {
  _internal_set_is_vote(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionInfo.is_vote)
}
inline bool SubscribeUpdateTransactionInfo::_internal_is_vote() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_vote_;
}
inline void SubscribeUpdateTransactionInfo::_internal_set_is_vote(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_vote_ = value;
}

// .solana.storage.ConfirmedBlock.Transaction transaction = 3;
inline bool SubscribeUpdateTransactionInfo::has_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transaction_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::Transaction& SubscribeUpdateTransactionInfo::_internal_transaction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::Transaction* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::Transaction&>(::solana::storage::ConfirmedBlock::_Transaction_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::Transaction& SubscribeUpdateTransactionInfo::transaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionInfo.transaction)
  return _internal_transaction();
}
inline void SubscribeUpdateTransactionInfo::unsafe_arena_set_allocated_transaction(
    ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Transaction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateTransactionInfo.transaction)
}
inline ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE SubscribeUpdateTransactionInfo::release_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::solana::storage::ConfirmedBlock::Transaction* released = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE SubscribeUpdateTransactionInfo::unsafe_arena_release_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateTransactionInfo.transaction)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::solana::storage::ConfirmedBlock::Transaction* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NONNULL SubscribeUpdateTransactionInfo::_internal_mutable_transaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transaction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::Transaction>(GetArena());
    _impl_.transaction_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Transaction*>(p);
  }
  return _impl_.transaction_;
}
inline ::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NONNULL SubscribeUpdateTransactionInfo::mutable_transaction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::solana::storage::ConfirmedBlock::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateTransactionInfo.transaction)
  return _msg;
}
inline void SubscribeUpdateTransactionInfo::set_allocated_transaction(::solana::storage::ConfirmedBlock::Transaction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transaction_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Transaction*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateTransactionInfo.transaction)
}

// .solana.storage.ConfirmedBlock.TransactionStatusMeta meta = 4;
inline bool SubscribeUpdateTransactionInfo::has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::TransactionStatusMeta& SubscribeUpdateTransactionInfo::_internal_meta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::TransactionStatusMeta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::TransactionStatusMeta&>(::solana::storage::ConfirmedBlock::_TransactionStatusMeta_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::TransactionStatusMeta& SubscribeUpdateTransactionInfo::meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionInfo.meta)
  return _internal_meta();
}
inline void SubscribeUpdateTransactionInfo::unsafe_arena_set_allocated_meta(
    ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = reinterpret_cast<::solana::storage::ConfirmedBlock::TransactionStatusMeta*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateTransactionInfo.meta)
}
inline ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE SubscribeUpdateTransactionInfo::release_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::solana::storage::ConfirmedBlock::TransactionStatusMeta* released = _impl_.meta_;
  _impl_.meta_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE SubscribeUpdateTransactionInfo::unsafe_arena_release_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateTransactionInfo.meta)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::solana::storage::ConfirmedBlock::TransactionStatusMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NONNULL SubscribeUpdateTransactionInfo::_internal_mutable_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.meta_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::TransactionStatusMeta>(GetArena());
    _impl_.meta_ = reinterpret_cast<::solana::storage::ConfirmedBlock::TransactionStatusMeta*>(p);
  }
  return _impl_.meta_;
}
inline ::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NONNULL SubscribeUpdateTransactionInfo::mutable_meta()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::solana::storage::ConfirmedBlock::TransactionStatusMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateTransactionInfo.meta)
  return _msg;
}
inline void SubscribeUpdateTransactionInfo::set_allocated_meta(::solana::storage::ConfirmedBlock::TransactionStatusMeta* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.meta_ = reinterpret_cast<::solana::storage::ConfirmedBlock::TransactionStatusMeta*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateTransactionInfo.meta)
}

// uint64 index = 5;
inline void SubscribeUpdateTransactionInfo::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t SubscribeUpdateTransactionInfo::index() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionInfo.index)
  return _internal_index();
}
inline void SubscribeUpdateTransactionInfo::set_index(::uint64_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionInfo.index)
}
inline ::uint64_t SubscribeUpdateTransactionInfo::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void SubscribeUpdateTransactionInfo::_internal_set_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// SubscribeUpdateTransactionStatus

// uint64 slot = 1;
inline void SubscribeUpdateTransactionStatus::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t SubscribeUpdateTransactionStatus::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionStatus.slot)
  return _internal_slot();
}
inline void SubscribeUpdateTransactionStatus::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionStatus.slot)
}
inline ::uint64_t SubscribeUpdateTransactionStatus::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateTransactionStatus::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// bytes signature = 2;
inline void SubscribeUpdateTransactionStatus::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateTransactionStatus::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionStatus.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateTransactionStatus::set_signature(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionStatus.signature)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateTransactionStatus::mutable_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateTransactionStatus.signature)
  return _s;
}
inline const ::std::string& SubscribeUpdateTransactionStatus::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void SubscribeUpdateTransactionStatus::_internal_set_signature(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateTransactionStatus::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateTransactionStatus::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateTransactionStatus.signature)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.signature_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.signature_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateTransactionStatus::set_allocated_signature(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateTransactionStatus.signature)
}

// bool is_vote = 3;
inline void SubscribeUpdateTransactionStatus::clear_is_vote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_vote_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SubscribeUpdateTransactionStatus::is_vote() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionStatus.is_vote)
  return _internal_is_vote();
}
inline void SubscribeUpdateTransactionStatus::set_is_vote(bool value) {
  _internal_set_is_vote(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionStatus.is_vote)
}
inline bool SubscribeUpdateTransactionStatus::_internal_is_vote() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_vote_;
}
inline void SubscribeUpdateTransactionStatus::_internal_set_is_vote(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_vote_ = value;
}

// uint64 index = 4;
inline void SubscribeUpdateTransactionStatus::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t SubscribeUpdateTransactionStatus::index() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionStatus.index)
  return _internal_index();
}
inline void SubscribeUpdateTransactionStatus::set_index(::uint64_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateTransactionStatus.index)
}
inline ::uint64_t SubscribeUpdateTransactionStatus::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void SubscribeUpdateTransactionStatus::_internal_set_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// .solana.storage.ConfirmedBlock.TransactionError err = 5;
inline bool SubscribeUpdateTransactionStatus::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::TransactionError& SubscribeUpdateTransactionStatus::_internal_err() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::TransactionError* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::TransactionError&>(::solana::storage::ConfirmedBlock::_TransactionError_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::TransactionError& SubscribeUpdateTransactionStatus::err() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateTransactionStatus.err)
  return _internal_err();
}
inline void SubscribeUpdateTransactionStatus::unsafe_arena_set_allocated_err(
    ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::solana::storage::ConfirmedBlock::TransactionError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateTransactionStatus.err)
}
inline ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE SubscribeUpdateTransactionStatus::release_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::solana::storage::ConfirmedBlock::TransactionError* released = _impl_.err_;
  _impl_.err_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE SubscribeUpdateTransactionStatus::unsafe_arena_release_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateTransactionStatus.err)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::solana::storage::ConfirmedBlock::TransactionError* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NONNULL SubscribeUpdateTransactionStatus::_internal_mutable_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.err_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::TransactionError>(GetArena());
    _impl_.err_ = reinterpret_cast<::solana::storage::ConfirmedBlock::TransactionError*>(p);
  }
  return _impl_.err_;
}
inline ::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NONNULL SubscribeUpdateTransactionStatus::mutable_err()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::solana::storage::ConfirmedBlock::TransactionError* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateTransactionStatus.err)
  return _msg;
}
inline void SubscribeUpdateTransactionStatus::set_allocated_err(::solana::storage::ConfirmedBlock::TransactionError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.err_ = reinterpret_cast<::solana::storage::ConfirmedBlock::TransactionError*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateTransactionStatus.err)
}

// -------------------------------------------------------------------

// SubscribeUpdateBlock

// uint64 slot = 1;
inline void SubscribeUpdateBlock::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t SubscribeUpdateBlock::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.slot)
  return _internal_slot();
}
inline void SubscribeUpdateBlock::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.slot)
}
inline ::uint64_t SubscribeUpdateBlock::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateBlock::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// string blockhash = 2;
inline void SubscribeUpdateBlock::clear_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateBlock::blockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.blockhash)
  return _internal_blockhash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateBlock::set_blockhash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.blockhash)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_blockhash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.blockhash)
  return _s;
}
inline const ::std::string& SubscribeUpdateBlock::_internal_blockhash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockhash_.Get();
}
inline void SubscribeUpdateBlock::_internal_set_blockhash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlock::_internal_mutable_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.blockhash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateBlock::release_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlock.blockhash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.blockhash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateBlock::set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.blockhash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlock.blockhash)
}

// .solana.storage.ConfirmedBlock.Rewards rewards = 3;
inline bool SubscribeUpdateBlock::has_rewards() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rewards_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::Rewards& SubscribeUpdateBlock::_internal_rewards() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::Rewards* p = _impl_.rewards_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::Rewards&>(::solana::storage::ConfirmedBlock::_Rewards_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::Rewards& SubscribeUpdateBlock::rewards() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.rewards)
  return _internal_rewards();
}
inline void SubscribeUpdateBlock::unsafe_arena_set_allocated_rewards(
    ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rewards_);
  }
  _impl_.rewards_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Rewards*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateBlock.rewards)
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE SubscribeUpdateBlock::release_rewards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::solana::storage::ConfirmedBlock::Rewards* released = _impl_.rewards_;
  _impl_.rewards_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE SubscribeUpdateBlock::unsafe_arena_release_rewards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlock.rewards)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::solana::storage::ConfirmedBlock::Rewards* temp = _impl_.rewards_;
  _impl_.rewards_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL SubscribeUpdateBlock::_internal_mutable_rewards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rewards_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::Rewards>(GetArena());
    _impl_.rewards_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Rewards*>(p);
  }
  return _impl_.rewards_;
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_rewards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::solana::storage::ConfirmedBlock::Rewards* _msg = _internal_mutable_rewards();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.rewards)
  return _msg;
}
inline void SubscribeUpdateBlock::set_allocated_rewards(::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rewards_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rewards_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Rewards*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlock.rewards)
}

// .solana.storage.ConfirmedBlock.UnixTimestamp block_time = 4;
inline bool SubscribeUpdateBlock::has_block_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_time_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::UnixTimestamp& SubscribeUpdateBlock::_internal_block_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::UnixTimestamp* p = _impl_.block_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::UnixTimestamp&>(::solana::storage::ConfirmedBlock::_UnixTimestamp_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::UnixTimestamp& SubscribeUpdateBlock::block_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.block_time)
  return _internal_block_time();
}
inline void SubscribeUpdateBlock::unsafe_arena_set_allocated_block_time(
    ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_time_);
  }
  _impl_.block_time_ = reinterpret_cast<::solana::storage::ConfirmedBlock::UnixTimestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateBlock.block_time)
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE SubscribeUpdateBlock::release_block_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* released = _impl_.block_time_;
  _impl_.block_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE SubscribeUpdateBlock::unsafe_arena_release_block_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlock.block_time)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* temp = _impl_.block_time_;
  _impl_.block_time_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL SubscribeUpdateBlock::_internal_mutable_block_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::UnixTimestamp>(GetArena());
    _impl_.block_time_ = reinterpret_cast<::solana::storage::ConfirmedBlock::UnixTimestamp*>(p);
  }
  return _impl_.block_time_;
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_block_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* _msg = _internal_mutable_block_time();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.block_time)
  return _msg;
}
inline void SubscribeUpdateBlock::set_allocated_block_time(::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.block_time_ = reinterpret_cast<::solana::storage::ConfirmedBlock::UnixTimestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlock.block_time)
}

// .solana.storage.ConfirmedBlock.BlockHeight block_height = 5;
inline bool SubscribeUpdateBlock::has_block_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_height_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::BlockHeight& SubscribeUpdateBlock::_internal_block_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::BlockHeight* p = _impl_.block_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::BlockHeight&>(::solana::storage::ConfirmedBlock::_BlockHeight_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::BlockHeight& SubscribeUpdateBlock::block_height() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.block_height)
  return _internal_block_height();
}
inline void SubscribeUpdateBlock::unsafe_arena_set_allocated_block_height(
    ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_height_);
  }
  _impl_.block_height_ = reinterpret_cast<::solana::storage::ConfirmedBlock::BlockHeight*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateBlock.block_height)
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE SubscribeUpdateBlock::release_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::solana::storage::ConfirmedBlock::BlockHeight* released = _impl_.block_height_;
  _impl_.block_height_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE SubscribeUpdateBlock::unsafe_arena_release_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlock.block_height)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::solana::storage::ConfirmedBlock::BlockHeight* temp = _impl_.block_height_;
  _impl_.block_height_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL SubscribeUpdateBlock::_internal_mutable_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_height_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::BlockHeight>(GetArena());
    _impl_.block_height_ = reinterpret_cast<::solana::storage::ConfirmedBlock::BlockHeight*>(p);
  }
  return _impl_.block_height_;
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_block_height()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::solana::storage::ConfirmedBlock::BlockHeight* _msg = _internal_mutable_block_height();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.block_height)
  return _msg;
}
inline void SubscribeUpdateBlock::set_allocated_block_height(::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_height_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.block_height_ = reinterpret_cast<::solana::storage::ConfirmedBlock::BlockHeight*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlock.block_height)
}

// uint64 parent_slot = 7;
inline void SubscribeUpdateBlock::clear_parent_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t SubscribeUpdateBlock::parent_slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.parent_slot)
  return _internal_parent_slot();
}
inline void SubscribeUpdateBlock::set_parent_slot(::uint64_t value) {
  _internal_set_parent_slot(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.parent_slot)
}
inline ::uint64_t SubscribeUpdateBlock::_internal_parent_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_slot_;
}
inline void SubscribeUpdateBlock::_internal_set_parent_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_slot_ = value;
}

// string parent_blockhash = 8;
inline void SubscribeUpdateBlock::clear_parent_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_blockhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SubscribeUpdateBlock::parent_blockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.parent_blockhash)
  return _internal_parent_blockhash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateBlock::set_parent_blockhash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_blockhash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.parent_blockhash)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_parent_blockhash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_parent_blockhash();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.parent_blockhash)
  return _s;
}
inline const ::std::string& SubscribeUpdateBlock::_internal_parent_blockhash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_blockhash_.Get();
}
inline void SubscribeUpdateBlock::_internal_set_parent_blockhash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_blockhash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlock::_internal_mutable_parent_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.parent_blockhash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateBlock::release_parent_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlock.parent_blockhash)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.parent_blockhash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.parent_blockhash_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateBlock::set_allocated_parent_blockhash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parent_blockhash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_blockhash_.IsDefault()) {
    _impl_.parent_blockhash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlock.parent_blockhash)
}

// uint64 executed_transaction_count = 9;
inline void SubscribeUpdateBlock::clear_executed_transaction_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_transaction_count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t SubscribeUpdateBlock::executed_transaction_count() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.executed_transaction_count)
  return _internal_executed_transaction_count();
}
inline void SubscribeUpdateBlock::set_executed_transaction_count(::uint64_t value) {
  _internal_set_executed_transaction_count(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.executed_transaction_count)
}
inline ::uint64_t SubscribeUpdateBlock::_internal_executed_transaction_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executed_transaction_count_;
}
inline void SubscribeUpdateBlock::_internal_set_executed_transaction_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_transaction_count_ = value;
}

// repeated .geyser.SubscribeUpdateTransactionInfo transactions = 6;
inline int SubscribeUpdateBlock::_internal_transactions_size() const {
  return _internal_transactions().size();
}
inline int SubscribeUpdateBlock::transactions_size() const {
  return _internal_transactions_size();
}
inline void SubscribeUpdateBlock::clear_transactions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transactions_.Clear();
}
inline ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_transactions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.transactions)
  return _internal_mutable_transactions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_transactions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeUpdateBlock.transactions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transactions();
}
inline const ::geyser::SubscribeUpdateTransactionInfo& SubscribeUpdateBlock::transactions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.transactions)
  return _internal_transactions().Get(index);
}
inline ::geyser::SubscribeUpdateTransactionInfo* PROTOBUF_NONNULL SubscribeUpdateBlock::add_transactions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::geyser::SubscribeUpdateTransactionInfo* _add = _internal_mutable_transactions()->Add();
  // @@protoc_insertion_point(field_add:geyser.SubscribeUpdateBlock.transactions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>& SubscribeUpdateBlock::transactions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeUpdateBlock.transactions)
  return _internal_transactions();
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>&
SubscribeUpdateBlock::_internal_transactions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transactions_;
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateTransactionInfo>* PROTOBUF_NONNULL
SubscribeUpdateBlock::_internal_mutable_transactions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transactions_;
}

// uint64 updated_account_count = 10;
inline void SubscribeUpdateBlock::clear_updated_account_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_account_count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t SubscribeUpdateBlock::updated_account_count() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.updated_account_count)
  return _internal_updated_account_count();
}
inline void SubscribeUpdateBlock::set_updated_account_count(::uint64_t value) {
  _internal_set_updated_account_count(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.updated_account_count)
}
inline ::uint64_t SubscribeUpdateBlock::_internal_updated_account_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_account_count_;
}
inline void SubscribeUpdateBlock::_internal_set_updated_account_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_account_count_ = value;
}

// repeated .geyser.SubscribeUpdateAccountInfo accounts = 11;
inline int SubscribeUpdateBlock::_internal_accounts_size() const {
  return _internal_accounts().size();
}
inline int SubscribeUpdateBlock::accounts_size() const {
  return _internal_accounts_size();
}
inline void SubscribeUpdateBlock::clear_accounts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accounts_.Clear();
}
inline ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_accounts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.accounts)
  return _internal_mutable_accounts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_accounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeUpdateBlock.accounts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_accounts();
}
inline const ::geyser::SubscribeUpdateAccountInfo& SubscribeUpdateBlock::accounts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.accounts)
  return _internal_accounts().Get(index);
}
inline ::geyser::SubscribeUpdateAccountInfo* PROTOBUF_NONNULL SubscribeUpdateBlock::add_accounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::geyser::SubscribeUpdateAccountInfo* _add = _internal_mutable_accounts()->Add();
  // @@protoc_insertion_point(field_add:geyser.SubscribeUpdateBlock.accounts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>& SubscribeUpdateBlock::accounts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeUpdateBlock.accounts)
  return _internal_accounts();
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>&
SubscribeUpdateBlock::_internal_accounts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.accounts_;
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateAccountInfo>* PROTOBUF_NONNULL
SubscribeUpdateBlock::_internal_mutable_accounts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.accounts_;
}

// uint64 entries_count = 12;
inline void SubscribeUpdateBlock::clear_entries_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t SubscribeUpdateBlock::entries_count() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.entries_count)
  return _internal_entries_count();
}
inline void SubscribeUpdateBlock::set_entries_count(::uint64_t value) {
  _internal_set_entries_count(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlock.entries_count)
}
inline ::uint64_t SubscribeUpdateBlock::_internal_entries_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_count_;
}
inline void SubscribeUpdateBlock::_internal_set_entries_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_count_ = value;
}

// repeated .geyser.SubscribeUpdateEntry entries = 13;
inline int SubscribeUpdateBlock::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int SubscribeUpdateBlock::entries_size() const {
  return _internal_entries_size();
}
inline void SubscribeUpdateBlock::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlock.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>* PROTOBUF_NONNULL SubscribeUpdateBlock::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:geyser.SubscribeUpdateBlock.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::geyser::SubscribeUpdateEntry& SubscribeUpdateBlock::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlock.entries)
  return _internal_entries().Get(index);
}
inline ::geyser::SubscribeUpdateEntry* PROTOBUF_NONNULL SubscribeUpdateBlock::add_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::geyser::SubscribeUpdateEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:geyser.SubscribeUpdateBlock.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>& SubscribeUpdateBlock::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:geyser.SubscribeUpdateBlock.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>&
SubscribeUpdateBlock::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::geyser::SubscribeUpdateEntry>* PROTOBUF_NONNULL
SubscribeUpdateBlock::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// SubscribeUpdateBlockMeta

// uint64 slot = 1;
inline void SubscribeUpdateBlockMeta::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t SubscribeUpdateBlockMeta::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.slot)
  return _internal_slot();
}
inline void SubscribeUpdateBlockMeta::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlockMeta.slot)
}
inline ::uint64_t SubscribeUpdateBlockMeta::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateBlockMeta::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// string blockhash = 2;
inline void SubscribeUpdateBlockMeta::clear_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateBlockMeta::blockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.blockhash)
  return _internal_blockhash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateBlockMeta::set_blockhash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlockMeta.blockhash)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::mutable_blockhash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlockMeta.blockhash)
  return _s;
}
inline const ::std::string& SubscribeUpdateBlockMeta::_internal_blockhash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockhash_.Get();
}
inline void SubscribeUpdateBlockMeta::_internal_set_blockhash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::_internal_mutable_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.blockhash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::release_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlockMeta.blockhash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.blockhash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateBlockMeta::set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.blockhash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlockMeta.blockhash)
}

// .solana.storage.ConfirmedBlock.Rewards rewards = 3;
inline bool SubscribeUpdateBlockMeta::has_rewards() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rewards_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::Rewards& SubscribeUpdateBlockMeta::_internal_rewards() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::Rewards* p = _impl_.rewards_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::Rewards&>(::solana::storage::ConfirmedBlock::_Rewards_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::Rewards& SubscribeUpdateBlockMeta::rewards() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.rewards)
  return _internal_rewards();
}
inline void SubscribeUpdateBlockMeta::unsafe_arena_set_allocated_rewards(
    ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rewards_);
  }
  _impl_.rewards_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Rewards*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateBlockMeta.rewards)
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::release_rewards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::solana::storage::ConfirmedBlock::Rewards* released = _impl_.rewards_;
  _impl_.rewards_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::unsafe_arena_release_rewards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlockMeta.rewards)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::solana::storage::ConfirmedBlock::Rewards* temp = _impl_.rewards_;
  _impl_.rewards_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::_internal_mutable_rewards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rewards_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::Rewards>(GetArena());
    _impl_.rewards_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Rewards*>(p);
  }
  return _impl_.rewards_;
}
inline ::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::mutable_rewards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::solana::storage::ConfirmedBlock::Rewards* _msg = _internal_mutable_rewards();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlockMeta.rewards)
  return _msg;
}
inline void SubscribeUpdateBlockMeta::set_allocated_rewards(::solana::storage::ConfirmedBlock::Rewards* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rewards_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rewards_ = reinterpret_cast<::solana::storage::ConfirmedBlock::Rewards*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlockMeta.rewards)
}

// .solana.storage.ConfirmedBlock.UnixTimestamp block_time = 4;
inline bool SubscribeUpdateBlockMeta::has_block_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_time_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::UnixTimestamp& SubscribeUpdateBlockMeta::_internal_block_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::UnixTimestamp* p = _impl_.block_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::UnixTimestamp&>(::solana::storage::ConfirmedBlock::_UnixTimestamp_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::UnixTimestamp& SubscribeUpdateBlockMeta::block_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.block_time)
  return _internal_block_time();
}
inline void SubscribeUpdateBlockMeta::unsafe_arena_set_allocated_block_time(
    ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_time_);
  }
  _impl_.block_time_ = reinterpret_cast<::solana::storage::ConfirmedBlock::UnixTimestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateBlockMeta.block_time)
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::release_block_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* released = _impl_.block_time_;
  _impl_.block_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::unsafe_arena_release_block_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlockMeta.block_time)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* temp = _impl_.block_time_;
  _impl_.block_time_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::_internal_mutable_block_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::UnixTimestamp>(GetArena());
    _impl_.block_time_ = reinterpret_cast<::solana::storage::ConfirmedBlock::UnixTimestamp*>(p);
  }
  return _impl_.block_time_;
}
inline ::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::mutable_block_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::solana::storage::ConfirmedBlock::UnixTimestamp* _msg = _internal_mutable_block_time();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlockMeta.block_time)
  return _msg;
}
inline void SubscribeUpdateBlockMeta::set_allocated_block_time(::solana::storage::ConfirmedBlock::UnixTimestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.block_time_ = reinterpret_cast<::solana::storage::ConfirmedBlock::UnixTimestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlockMeta.block_time)
}

// .solana.storage.ConfirmedBlock.BlockHeight block_height = 5;
inline bool SubscribeUpdateBlockMeta::has_block_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_height_ != nullptr);
  return value;
}
inline const ::solana::storage::ConfirmedBlock::BlockHeight& SubscribeUpdateBlockMeta::_internal_block_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::solana::storage::ConfirmedBlock::BlockHeight* p = _impl_.block_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::solana::storage::ConfirmedBlock::BlockHeight&>(::solana::storage::ConfirmedBlock::_BlockHeight_default_instance_);
}
inline const ::solana::storage::ConfirmedBlock::BlockHeight& SubscribeUpdateBlockMeta::block_height() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.block_height)
  return _internal_block_height();
}
inline void SubscribeUpdateBlockMeta::unsafe_arena_set_allocated_block_height(
    ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_height_);
  }
  _impl_.block_height_ = reinterpret_cast<::solana::storage::ConfirmedBlock::BlockHeight*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:geyser.SubscribeUpdateBlockMeta.block_height)
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::release_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::solana::storage::ConfirmedBlock::BlockHeight* released = _impl_.block_height_;
  _impl_.block_height_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::unsafe_arena_release_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlockMeta.block_height)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::solana::storage::ConfirmedBlock::BlockHeight* temp = _impl_.block_height_;
  _impl_.block_height_ = nullptr;
  return temp;
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::_internal_mutable_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_height_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::solana::storage::ConfirmedBlock::BlockHeight>(GetArena());
    _impl_.block_height_ = reinterpret_cast<::solana::storage::ConfirmedBlock::BlockHeight*>(p);
  }
  return _impl_.block_height_;
}
inline ::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::mutable_block_height()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::solana::storage::ConfirmedBlock::BlockHeight* _msg = _internal_mutable_block_height();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlockMeta.block_height)
  return _msg;
}
inline void SubscribeUpdateBlockMeta::set_allocated_block_height(::solana::storage::ConfirmedBlock::BlockHeight* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_height_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.block_height_ = reinterpret_cast<::solana::storage::ConfirmedBlock::BlockHeight*>(value);
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlockMeta.block_height)
}

// uint64 parent_slot = 6;
inline void SubscribeUpdateBlockMeta::clear_parent_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t SubscribeUpdateBlockMeta::parent_slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.parent_slot)
  return _internal_parent_slot();
}
inline void SubscribeUpdateBlockMeta::set_parent_slot(::uint64_t value) {
  _internal_set_parent_slot(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlockMeta.parent_slot)
}
inline ::uint64_t SubscribeUpdateBlockMeta::_internal_parent_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_slot_;
}
inline void SubscribeUpdateBlockMeta::_internal_set_parent_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_slot_ = value;
}

// string parent_blockhash = 7;
inline void SubscribeUpdateBlockMeta::clear_parent_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_blockhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SubscribeUpdateBlockMeta::parent_blockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.parent_blockhash)
  return _internal_parent_blockhash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateBlockMeta::set_parent_blockhash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_blockhash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlockMeta.parent_blockhash)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::mutable_parent_blockhash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_parent_blockhash();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateBlockMeta.parent_blockhash)
  return _s;
}
inline const ::std::string& SubscribeUpdateBlockMeta::_internal_parent_blockhash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_blockhash_.Get();
}
inline void SubscribeUpdateBlockMeta::_internal_set_parent_blockhash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_blockhash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateBlockMeta::_internal_mutable_parent_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.parent_blockhash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateBlockMeta::release_parent_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateBlockMeta.parent_blockhash)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.parent_blockhash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.parent_blockhash_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateBlockMeta::set_allocated_parent_blockhash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parent_blockhash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_blockhash_.IsDefault()) {
    _impl_.parent_blockhash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateBlockMeta.parent_blockhash)
}

// uint64 executed_transaction_count = 8;
inline void SubscribeUpdateBlockMeta::clear_executed_transaction_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_transaction_count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t SubscribeUpdateBlockMeta::executed_transaction_count() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.executed_transaction_count)
  return _internal_executed_transaction_count();
}
inline void SubscribeUpdateBlockMeta::set_executed_transaction_count(::uint64_t value) {
  _internal_set_executed_transaction_count(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlockMeta.executed_transaction_count)
}
inline ::uint64_t SubscribeUpdateBlockMeta::_internal_executed_transaction_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executed_transaction_count_;
}
inline void SubscribeUpdateBlockMeta::_internal_set_executed_transaction_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_transaction_count_ = value;
}

// uint64 entries_count = 9;
inline void SubscribeUpdateBlockMeta::clear_entries_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t SubscribeUpdateBlockMeta::entries_count() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateBlockMeta.entries_count)
  return _internal_entries_count();
}
inline void SubscribeUpdateBlockMeta::set_entries_count(::uint64_t value) {
  _internal_set_entries_count(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateBlockMeta.entries_count)
}
inline ::uint64_t SubscribeUpdateBlockMeta::_internal_entries_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_count_;
}
inline void SubscribeUpdateBlockMeta::_internal_set_entries_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_count_ = value;
}

// -------------------------------------------------------------------

// SubscribeUpdateEntry

// uint64 slot = 1;
inline void SubscribeUpdateEntry::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SubscribeUpdateEntry::slot() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateEntry.slot)
  return _internal_slot();
}
inline void SubscribeUpdateEntry::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateEntry.slot)
}
inline ::uint64_t SubscribeUpdateEntry::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void SubscribeUpdateEntry::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// uint64 index = 2;
inline void SubscribeUpdateEntry::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t SubscribeUpdateEntry::index() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateEntry.index)
  return _internal_index();
}
inline void SubscribeUpdateEntry::set_index(::uint64_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateEntry.index)
}
inline ::uint64_t SubscribeUpdateEntry::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void SubscribeUpdateEntry::_internal_set_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// uint64 num_hashes = 3;
inline void SubscribeUpdateEntry::clear_num_hashes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_hashes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t SubscribeUpdateEntry::num_hashes() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateEntry.num_hashes)
  return _internal_num_hashes();
}
inline void SubscribeUpdateEntry::set_num_hashes(::uint64_t value) {
  _internal_set_num_hashes(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateEntry.num_hashes)
}
inline ::uint64_t SubscribeUpdateEntry::_internal_num_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_hashes_;
}
inline void SubscribeUpdateEntry::_internal_set_num_hashes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_hashes_ = value;
}

// bytes hash = 4;
inline void SubscribeUpdateEntry::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubscribeUpdateEntry::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateEntry.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeUpdateEntry::set_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateEntry.hash)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateEntry::mutable_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:geyser.SubscribeUpdateEntry.hash)
  return _s;
}
inline const ::std::string& SubscribeUpdateEntry::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void SubscribeUpdateEntry::_internal_set_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeUpdateEntry::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeUpdateEntry::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.SubscribeUpdateEntry.hash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeUpdateEntry::set_allocated_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.SubscribeUpdateEntry.hash)
}

// uint64 executed_transaction_count = 5;
inline void SubscribeUpdateEntry::clear_executed_transaction_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_transaction_count_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t SubscribeUpdateEntry::executed_transaction_count() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateEntry.executed_transaction_count)
  return _internal_executed_transaction_count();
}
inline void SubscribeUpdateEntry::set_executed_transaction_count(::uint64_t value) {
  _internal_set_executed_transaction_count(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateEntry.executed_transaction_count)
}
inline ::uint64_t SubscribeUpdateEntry::_internal_executed_transaction_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executed_transaction_count_;
}
inline void SubscribeUpdateEntry::_internal_set_executed_transaction_count(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_transaction_count_ = value;
}

// uint64 starting_transaction_index = 6;
inline void SubscribeUpdateEntry::clear_starting_transaction_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_transaction_index_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t SubscribeUpdateEntry::starting_transaction_index() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdateEntry.starting_transaction_index)
  return _internal_starting_transaction_index();
}
inline void SubscribeUpdateEntry::set_starting_transaction_index(::uint64_t value) {
  _internal_set_starting_transaction_index(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdateEntry.starting_transaction_index)
}
inline ::uint64_t SubscribeUpdateEntry::_internal_starting_transaction_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.starting_transaction_index_;
}
inline void SubscribeUpdateEntry::_internal_set_starting_transaction_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_transaction_index_ = value;
}

// -------------------------------------------------------------------

// SubscribeUpdatePing

// -------------------------------------------------------------------

// SubscribeUpdatePong

// int32 id = 1;
inline void SubscribeUpdatePong::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SubscribeUpdatePong::id() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeUpdatePong.id)
  return _internal_id();
}
inline void SubscribeUpdatePong::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeUpdatePong.id)
}
inline ::int32_t SubscribeUpdatePong::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void SubscribeUpdatePong::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// SubscribeReplayInfoRequest

// -------------------------------------------------------------------

// SubscribeReplayInfoResponse

// optional uint64 first_available = 1;
inline bool SubscribeReplayInfoResponse::has_first_available() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SubscribeReplayInfoResponse::clear_first_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_available_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SubscribeReplayInfoResponse::first_available() const {
  // @@protoc_insertion_point(field_get:geyser.SubscribeReplayInfoResponse.first_available)
  return _internal_first_available();
}
inline void SubscribeReplayInfoResponse::set_first_available(::uint64_t value) {
  _internal_set_first_available(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.SubscribeReplayInfoResponse.first_available)
}
inline ::uint64_t SubscribeReplayInfoResponse::_internal_first_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.first_available_;
}
inline void SubscribeReplayInfoResponse::_internal_set_first_available(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_available_ = value;
}

// -------------------------------------------------------------------

// PingRequest

// int32 count = 1;
inline void PingRequest::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t PingRequest::count() const {
  // @@protoc_insertion_point(field_get:geyser.PingRequest.count)
  return _internal_count();
}
inline void PingRequest::set_count(::int32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.PingRequest.count)
}
inline ::int32_t PingRequest::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void PingRequest::_internal_set_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// PongResponse

// int32 count = 1;
inline void PongResponse::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t PongResponse::count() const {
  // @@protoc_insertion_point(field_get:geyser.PongResponse.count)
  return _internal_count();
}
inline void PongResponse::set_count(::int32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.PongResponse.count)
}
inline ::int32_t PongResponse::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void PongResponse::_internal_set_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// GetLatestBlockhashRequest

// optional .geyser.CommitmentLevel commitment = 1;
inline bool GetLatestBlockhashRequest::has_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetLatestBlockhashRequest::clear_commitment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::geyser::CommitmentLevel GetLatestBlockhashRequest::commitment() const {
  // @@protoc_insertion_point(field_get:geyser.GetLatestBlockhashRequest.commitment)
  return _internal_commitment();
}
inline void GetLatestBlockhashRequest::set_commitment(::geyser::CommitmentLevel value) {
  _internal_set_commitment(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.GetLatestBlockhashRequest.commitment)
}
inline ::geyser::CommitmentLevel GetLatestBlockhashRequest::_internal_commitment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::geyser::CommitmentLevel>(_impl_.commitment_);
}
inline void GetLatestBlockhashRequest::_internal_set_commitment(::geyser::CommitmentLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = value;
}

// -------------------------------------------------------------------

// GetLatestBlockhashResponse

// uint64 slot = 1;
inline void GetLatestBlockhashResponse::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t GetLatestBlockhashResponse::slot() const {
  // @@protoc_insertion_point(field_get:geyser.GetLatestBlockhashResponse.slot)
  return _internal_slot();
}
inline void GetLatestBlockhashResponse::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.GetLatestBlockhashResponse.slot)
}
inline ::uint64_t GetLatestBlockhashResponse::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void GetLatestBlockhashResponse::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// string blockhash = 2;
inline void GetLatestBlockhashResponse::clear_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetLatestBlockhashResponse::blockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.GetLatestBlockhashResponse.blockhash)
  return _internal_blockhash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetLatestBlockhashResponse::set_blockhash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.GetLatestBlockhashResponse.blockhash)
}
inline ::std::string* PROTOBUF_NONNULL GetLatestBlockhashResponse::mutable_blockhash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:geyser.GetLatestBlockhashResponse.blockhash)
  return _s;
}
inline const ::std::string& GetLatestBlockhashResponse::_internal_blockhash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockhash_.Get();
}
inline void GetLatestBlockhashResponse::_internal_set_blockhash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetLatestBlockhashResponse::_internal_mutable_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.blockhash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetLatestBlockhashResponse::release_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.GetLatestBlockhashResponse.blockhash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.blockhash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  return released;
}
inline void GetLatestBlockhashResponse::set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.blockhash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.GetLatestBlockhashResponse.blockhash)
}

// uint64 last_valid_block_height = 3;
inline void GetLatestBlockhashResponse::clear_last_valid_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_valid_block_height_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t GetLatestBlockhashResponse::last_valid_block_height() const {
  // @@protoc_insertion_point(field_get:geyser.GetLatestBlockhashResponse.last_valid_block_height)
  return _internal_last_valid_block_height();
}
inline void GetLatestBlockhashResponse::set_last_valid_block_height(::uint64_t value) {
  _internal_set_last_valid_block_height(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:geyser.GetLatestBlockhashResponse.last_valid_block_height)
}
inline ::uint64_t GetLatestBlockhashResponse::_internal_last_valid_block_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_valid_block_height_;
}
inline void GetLatestBlockhashResponse::_internal_set_last_valid_block_height(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_valid_block_height_ = value;
}

// -------------------------------------------------------------------

// GetBlockHeightRequest

// optional .geyser.CommitmentLevel commitment = 1;
inline bool GetBlockHeightRequest::has_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetBlockHeightRequest::clear_commitment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::geyser::CommitmentLevel GetBlockHeightRequest::commitment() const {
  // @@protoc_insertion_point(field_get:geyser.GetBlockHeightRequest.commitment)
  return _internal_commitment();
}
inline void GetBlockHeightRequest::set_commitment(::geyser::CommitmentLevel value) {
  _internal_set_commitment(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.GetBlockHeightRequest.commitment)
}
inline ::geyser::CommitmentLevel GetBlockHeightRequest::_internal_commitment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::geyser::CommitmentLevel>(_impl_.commitment_);
}
inline void GetBlockHeightRequest::_internal_set_commitment(::geyser::CommitmentLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = value;
}

// -------------------------------------------------------------------

// GetBlockHeightResponse

// uint64 block_height = 1;
inline void GetBlockHeightResponse::clear_block_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_height_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t GetBlockHeightResponse::block_height() const {
  // @@protoc_insertion_point(field_get:geyser.GetBlockHeightResponse.block_height)
  return _internal_block_height();
}
inline void GetBlockHeightResponse::set_block_height(::uint64_t value) {
  _internal_set_block_height(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.GetBlockHeightResponse.block_height)
}
inline ::uint64_t GetBlockHeightResponse::_internal_block_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_height_;
}
inline void GetBlockHeightResponse::_internal_set_block_height(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_height_ = value;
}

// -------------------------------------------------------------------

// GetSlotRequest

// optional .geyser.CommitmentLevel commitment = 1;
inline bool GetSlotRequest::has_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetSlotRequest::clear_commitment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::geyser::CommitmentLevel GetSlotRequest::commitment() const {
  // @@protoc_insertion_point(field_get:geyser.GetSlotRequest.commitment)
  return _internal_commitment();
}
inline void GetSlotRequest::set_commitment(::geyser::CommitmentLevel value) {
  _internal_set_commitment(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.GetSlotRequest.commitment)
}
inline ::geyser::CommitmentLevel GetSlotRequest::_internal_commitment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::geyser::CommitmentLevel>(_impl_.commitment_);
}
inline void GetSlotRequest::_internal_set_commitment(::geyser::CommitmentLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = value;
}

// -------------------------------------------------------------------

// GetSlotResponse

// uint64 slot = 1;
inline void GetSlotResponse::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t GetSlotResponse::slot() const {
  // @@protoc_insertion_point(field_get:geyser.GetSlotResponse.slot)
  return _internal_slot();
}
inline void GetSlotResponse::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.GetSlotResponse.slot)
}
inline ::uint64_t GetSlotResponse::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void GetSlotResponse::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// -------------------------------------------------------------------

// GetVersionRequest

// -------------------------------------------------------------------

// GetVersionResponse

// string version = 1;
inline void GetVersionResponse::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetVersionResponse::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.GetVersionResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetVersionResponse::set_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.GetVersionResponse.version)
}
inline ::std::string* PROTOBUF_NONNULL GetVersionResponse::mutable_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:geyser.GetVersionResponse.version)
  return _s;
}
inline const ::std::string& GetVersionResponse::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void GetVersionResponse::_internal_set_version(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetVersionResponse::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.version_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetVersionResponse::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.GetVersionResponse.version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.version_.Set("", GetArena());
  }
  return released;
}
inline void GetVersionResponse::set_allocated_version(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.GetVersionResponse.version)
}

// -------------------------------------------------------------------

// IsBlockhashValidRequest

// string blockhash = 1;
inline void IsBlockhashValidRequest::clear_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& IsBlockhashValidRequest::blockhash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:geyser.IsBlockhashValidRequest.blockhash)
  return _internal_blockhash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IsBlockhashValidRequest::set_blockhash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:geyser.IsBlockhashValidRequest.blockhash)
}
inline ::std::string* PROTOBUF_NONNULL IsBlockhashValidRequest::mutable_blockhash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:geyser.IsBlockhashValidRequest.blockhash)
  return _s;
}
inline const ::std::string& IsBlockhashValidRequest::_internal_blockhash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockhash_.Get();
}
inline void IsBlockhashValidRequest::_internal_set_blockhash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blockhash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL IsBlockhashValidRequest::_internal_mutable_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.blockhash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE IsBlockhashValidRequest::release_blockhash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:geyser.IsBlockhashValidRequest.blockhash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.blockhash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  return released;
}
inline void IsBlockhashValidRequest::set_allocated_blockhash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.blockhash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:geyser.IsBlockhashValidRequest.blockhash)
}

// optional .geyser.CommitmentLevel commitment = 2;
inline bool IsBlockhashValidRequest::has_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IsBlockhashValidRequest::clear_commitment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::geyser::CommitmentLevel IsBlockhashValidRequest::commitment() const {
  // @@protoc_insertion_point(field_get:geyser.IsBlockhashValidRequest.commitment)
  return _internal_commitment();
}
inline void IsBlockhashValidRequest::set_commitment(::geyser::CommitmentLevel value) {
  _internal_set_commitment(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.IsBlockhashValidRequest.commitment)
}
inline ::geyser::CommitmentLevel IsBlockhashValidRequest::_internal_commitment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::geyser::CommitmentLevel>(_impl_.commitment_);
}
inline void IsBlockhashValidRequest::_internal_set_commitment(::geyser::CommitmentLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitment_ = value;
}

// -------------------------------------------------------------------

// IsBlockhashValidResponse

// uint64 slot = 1;
inline void IsBlockhashValidResponse::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IsBlockhashValidResponse::slot() const {
  // @@protoc_insertion_point(field_get:geyser.IsBlockhashValidResponse.slot)
  return _internal_slot();
}
inline void IsBlockhashValidResponse::set_slot(::uint64_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:geyser.IsBlockhashValidResponse.slot)
}
inline ::uint64_t IsBlockhashValidResponse::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void IsBlockhashValidResponse::_internal_set_slot(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// bool valid = 2;
inline void IsBlockhashValidResponse::clear_valid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool IsBlockhashValidResponse::valid() const {
  // @@protoc_insertion_point(field_get:geyser.IsBlockhashValidResponse.valid)
  return _internal_valid();
}
inline void IsBlockhashValidResponse::set_valid(bool value) {
  _internal_set_valid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:geyser.IsBlockhashValidResponse.valid)
}
inline bool IsBlockhashValidResponse::_internal_valid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.valid_;
}
inline void IsBlockhashValidResponse::_internal_set_valid(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valid_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace geyser


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::geyser::CommitmentLevel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::geyser::CommitmentLevel>() {
  return ::geyser::CommitmentLevel_descriptor();
}
template <>
struct is_proto_enum<::geyser::SlotStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::geyser::SlotStatus>() {
  return ::geyser::SlotStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // geyser_2eproto_2epb_2eh
